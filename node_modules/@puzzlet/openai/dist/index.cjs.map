{"version":3,"sources":["../src/index.ts","../src/openai-chat.ts"],"sourcesContent":["import OpenAIChatPlugin from './openai-chat';\n\nexport { OpenAIChatPlugin };\nexport default OpenAIChatPlugin;","import {\n  ChatCompletionCreateParams,\n} from \"openai/resources\";\nimport type { IPluginAPI, IModelPlugin, InferenceOptions, AgentMarkOutput, AgentMark, AgentMarkStreamOutput, DeserializeConfig } from \"@puzzlet/agentmark\";\nimport { createOpenAI } from \"@ai-sdk/openai\";\n\nexport default class OpenAIChatPlugin implements IModelPlugin {\n  provider: string;\n  apiKey: string | undefined = \"\";\n  constructor() {\n    this.provider = \"openai\";\n  }\n\n  setApiKey(apiKey: string) {\n    this.apiKey = apiKey;\n  }\n\n\n  serialize(\n    completionParams: ChatCompletionCreateParams,\n    name: string,\n    api: IPluginAPI\n  ): string {\n    const { model, messages, tools, stream_options, tool_choice, ...settings } = completionParams;\n    const frontMatterData: any = {\n      name: name,\n      metadata: {\n        model: {\n          name: model,\n          settings: settings || {},\n        },\n      },\n    };\n  \n    if (tools) {\n      const transformedTools = tools.reduce((acc: any, { function: func }) => {\n        acc[func.name] = {\n          description: func.description,\n          parameters: func.parameters,\n        };\n        return acc;\n      }, {});\n  \n      if (tool_choice === 'auto') {\n        frontMatterData.metadata.model.settings.tools = transformedTools;\n      } else {\n        const schemaTool = tools.find((tool) => tool.function.parameters);\n        if (schemaTool) {\n          frontMatterData.metadata.model.settings.schema = schemaTool.function.parameters;\n        }\n      }\n    }\n  \n    const frontMatter = api.toFrontMatter(frontMatterData);\n    const messageBody = messages\n      .map((message) => {\n        const role = message.role;\n        const JSXTag = role.charAt(0).toUpperCase() + role.slice(1);\n        return `<${JSXTag}>${message.content}</${JSXTag}>`;\n      })\n      .join(\"\\n\");\n  \n    return `${frontMatter}\\n${messageBody}`;\n  }\n  \n\n  async deserialize(agentMark: AgentMark, api: IPluginAPI, config?: DeserializeConfig): Promise<ChatCompletionCreateParams> {\n    const { metadata, messages } = agentMark;\n    const { model: modelConfig } = metadata;\n    const completionParamsPromise = new Promise<ChatCompletionCreateParams>(\n      async (resolve) => {\n        const openai = createOpenAI({\n          compatibility: 'strict',\n          fetch: async (_, options) => {\n            const requestBody = JSON.parse(options!.body! as string);\n            resolve(requestBody as ChatCompletionCreateParams);\n            return new Response();\n          },\n        });\n        const providerModel = openai(modelConfig.name);\n        // Swallow any errors here. We only care about the deserialized inputs.\n        try {\n          if (config?.withStream) {\n            await api.streamInference(modelConfig.settings, providerModel, messages);\n          } else {\n            await api.runInference(modelConfig.settings, providerModel, messages);\n          }\n        } catch (e) {}\n      }\n    );\n    return completionParamsPromise;\n  }\n\n  async runInference(agentMark: AgentMark, api: IPluginAPI, options?: InferenceOptions): Promise<AgentMarkOutput> {\n    const apiKey = options?.apiKey || this.apiKey || api.getEnv(\"OPENAI_API_KEY\");\n    if (!apiKey) {\n      throw new Error(\"No API key provided\");\n    }\n    const openai = createOpenAI({\n      compatibility: 'strict',\n      apiKey,\n      fetch: api.fetch\n    });\n    const { metadata, messages } = agentMark;\n    const { model: modelConfig } = metadata;\n    const providerModel = openai(modelConfig.name);\n    const result = await api.runInference(modelConfig.settings, providerModel, messages, options);\n    return result;\n  }\n\n  async streamInference(agentMark: AgentMark, api: IPluginAPI, options?: InferenceOptions): Promise<AgentMarkStreamOutput<any>> {\n    const apiKey = options?.apiKey || this.apiKey || api.getEnv(\"OPENAI_API_KEY\");\n    if (!apiKey) {\n      throw new Error(\"No API key provided\");\n    }\n    const openai = createOpenAI({\n      compatibility: 'strict',\n      apiKey,\n      fetch: api.fetch\n    });\n    const { metadata, messages } = agentMark;\n    const { model: modelConfig } = metadata;\n    const providerModel = openai(modelConfig.name);\n    const result = await api.streamInference(modelConfig.settings, providerModel, messages, options);\n    return result;\n  }\n}\n"],"mappings":"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","names":[]}