"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AnthropicChatPlugin: () => AnthropicChatPlugin,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// src/anthropic-chat.ts
var import_anthropic = require("@ai-sdk/anthropic");
var AnthropicChatPlugin = class {
  constructor() {
    this.apiKey = "";
    this.provider = "anthropic";
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  serialize(completionParams, name, api) {
    const { model, messages, tools, tool_choice, stream, system, ...settings } = completionParams;
    const messagesWithSystem = [...messages];
    const metadata = {
      model: {
        name: model,
        settings: settings || {}
      }
    };
    if (system && Array.isArray(system) && system.length) {
      const systemMessages = system.map((msg) => ({
        role: "system",
        content: [{ text: msg.text, type: "text" }]
      }));
      messagesWithSystem.unshift(...systemMessages);
    }
    if (stream) {
      metadata.model.settings.stream = true;
    }
    if (tools) {
      if ((tool_choice == null ? void 0 : tool_choice.type) === "auto") {
        metadata.model.settings.tools = tools.reduce((acc, tool) => {
          acc[tool.name] = {
            description: tool.description,
            parameters: tool.input_schema || {}
          };
          return acc;
        }, {});
      } else {
        const schemaTool = tools.find((tool) => tool.input_schema);
        if (schemaTool) {
          metadata.model.settings.schema = schemaTool.input_schema;
        }
      }
    }
    const frontMatterData = {
      name,
      metadata
    };
    const frontMatter = api.toFrontMatter(frontMatterData);
    const capitalizeRole = (role) => role.charAt(0).toUpperCase() + role.slice(1);
    const messageBody = messagesWithSystem.map((message) => {
      const roleTag = `<${capitalizeRole(message.role)}>`;
      const content = message.content.map((part) => part.text).join(" ");
      return `${roleTag}${content}</${capitalizeRole(message.role)}>`;
    }).join("\n");
    return `${frontMatter}
${messageBody}`;
  }
  async deserialize(agentMark, api, config) {
    const { metadata, messages } = agentMark;
    const { model: modelConfig } = metadata;
    const completionParamsPromise = new Promise(
      async (resolve) => {
        const anthropic = (0, import_anthropic.createAnthropic)({
          fetch: async (_, options) => {
            const requestBody = JSON.parse(options.body);
            resolve(requestBody);
            return new Response();
          }
        });
        const providerModel = anthropic(modelConfig.name);
        try {
          if (config == null ? void 0 : config.withStream) {
            await api.streamInference(modelConfig.settings, providerModel, messages);
          } else {
            await api.runInference(modelConfig.settings, providerModel, messages);
          }
        } catch (e) {
        }
      }
    );
    return completionParamsPromise;
  }
  async runInference(agentMark, api, options) {
    const apiKey = (options == null ? void 0 : options.apiKey) || this.apiKey || api.getEnv("ANTHROPIC_API_KEY");
    if (!apiKey) {
      throw new Error("No API key provided");
    }
    const anthropic = (0, import_anthropic.createAnthropic)({
      apiKey,
      fetch: api.fetch
    });
    const { metadata, messages } = agentMark;
    const { model: modelConfig } = metadata;
    const providerModel = anthropic(modelConfig.name);
    const result = await api.runInference(modelConfig.settings, providerModel, messages, options);
    return result;
  }
  async streamInference(agentMark, api, options) {
    const apiKey = (options == null ? void 0 : options.apiKey) || this.apiKey || api.getEnv("ANTHROPIC_API_KEY");
    if (!apiKey) {
      throw new Error("No API key provided");
    }
    const anthropic = (0, import_anthropic.createAnthropic)({
      apiKey,
      fetch: api.fetch
    });
    const { metadata, messages } = agentMark;
    const { model: modelConfig } = metadata;
    const providerModel = anthropic(modelConfig.name);
    return api.streamInference(modelConfig.settings, providerModel, messages, options);
  }
};

// src/index.ts
var src_default = AnthropicChatPlugin;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AnthropicChatPlugin
});
//# sourceMappingURL=index.cjs.map