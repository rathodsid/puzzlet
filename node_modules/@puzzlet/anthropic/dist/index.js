// src/anthropic-chat.ts
import { createAnthropic } from "@ai-sdk/anthropic";
var AnthropicChatPlugin = class {
  constructor() {
    this.apiKey = "";
    this.provider = "anthropic";
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  serialize(completionParams, name, api) {
    const { model, messages, tools, tool_choice, stream, system, ...settings } = completionParams;
    const messagesWithSystem = [...messages];
    const metadata = {
      model: {
        name: model,
        settings: settings || {}
      }
    };
    if (system && Array.isArray(system) && system.length) {
      const systemMessages = system.map((msg) => ({
        role: "system",
        content: [{ text: msg.text, type: "text" }]
      }));
      messagesWithSystem.unshift(...systemMessages);
    }
    if (stream) {
      metadata.model.settings.stream = true;
    }
    if (tools) {
      if ((tool_choice == null ? void 0 : tool_choice.type) === "auto") {
        metadata.model.settings.tools = tools.reduce((acc, tool) => {
          acc[tool.name] = {
            description: tool.description,
            parameters: tool.input_schema || {}
          };
          return acc;
        }, {});
      } else {
        const schemaTool = tools.find((tool) => tool.input_schema);
        if (schemaTool) {
          metadata.model.settings.schema = schemaTool.input_schema;
        }
      }
    }
    const frontMatterData = {
      name,
      metadata
    };
    const frontMatter = api.toFrontMatter(frontMatterData);
    const capitalizeRole = (role) => role.charAt(0).toUpperCase() + role.slice(1);
    const messageBody = messagesWithSystem.map((message) => {
      const roleTag = `<${capitalizeRole(message.role)}>`;
      const content = message.content.map((part) => part.text).join(" ");
      return `${roleTag}${content}</${capitalizeRole(message.role)}>`;
    }).join("\n");
    return `${frontMatter}
${messageBody}`;
  }
  async deserialize(agentMark, api, config) {
    const { metadata, messages } = agentMark;
    const { model: modelConfig } = metadata;
    const completionParamsPromise = new Promise(
      async (resolve) => {
        const anthropic = createAnthropic({
          fetch: async (_, options) => {
            const requestBody = JSON.parse(options.body);
            resolve(requestBody);
            return new Response();
          }
        });
        const providerModel = anthropic(modelConfig.name);
        try {
          if (config == null ? void 0 : config.withStream) {
            await api.streamInference(modelConfig.settings, providerModel, messages);
          } else {
            await api.runInference(modelConfig.settings, providerModel, messages);
          }
        } catch (e) {
        }
      }
    );
    return completionParamsPromise;
  }
  async runInference(agentMark, api, options) {
    const apiKey = (options == null ? void 0 : options.apiKey) || this.apiKey || api.getEnv("ANTHROPIC_API_KEY");
    if (!apiKey) {
      throw new Error("No API key provided");
    }
    const anthropic = createAnthropic({
      apiKey,
      fetch: api.fetch
    });
    const { metadata, messages } = agentMark;
    const { model: modelConfig } = metadata;
    const providerModel = anthropic(modelConfig.name);
    const result = await api.runInference(modelConfig.settings, providerModel, messages, options);
    return result;
  }
  async streamInference(agentMark, api, options) {
    const apiKey = (options == null ? void 0 : options.apiKey) || this.apiKey || api.getEnv("ANTHROPIC_API_KEY");
    if (!apiKey) {
      throw new Error("No API key provided");
    }
    const anthropic = createAnthropic({
      apiKey,
      fetch: api.fetch
    });
    const { metadata, messages } = agentMark;
    const { model: modelConfig } = metadata;
    const providerModel = anthropic(modelConfig.name);
    return api.streamInference(modelConfig.settings, providerModel, messages, options);
  }
};

// src/index.ts
var src_default = AnthropicChatPlugin;
export {
  AnthropicChatPlugin,
  src_default as default
};
//# sourceMappingURL=index.js.map