{"version":3,"sources":["../src/transformer.ts","../src/constants.ts","../src/tag-plugin-registry.ts","../src/ast-utils.ts","../src/utils.ts","../src/filter-registry.ts","../src/scope.ts","../node_modules/mdast-util-mdx-expression/lib/index.js","../node_modules/ccount/index.js","../node_modules/stringify-entities/lib/core.js","../node_modules/stringify-entities/lib/util/format-basic.js","../node_modules/stringify-entities/lib/index.js","../node_modules/mdast-util-mdx-jsx/lib/index.js","../node_modules/mdast-util-mdxjs-esm/lib/index.js","../node_modules/mdast-util-mdx/lib/index.js","../src/bundler.ts","../src/tag-plugin.ts","../src/tag-plugins/for-each.ts","../src/tag-plugins/conditional.ts","../src/tag-plugins/raw.ts","../src/filter-plugins/index.ts","../src/register-builtin-plugins.ts","../src/index.ts"],"sourcesContent":["import jsep from 'jsep';\nimport jsepObject from '@jsep-plugin/object';\nimport {\n  MdxJsxFlowElement,\n  MdxJsxTextElement,\n} from 'mdast-util-mdx';\nimport { NODE_TYPES, MDX_JSX_ATTRIBUTE_TYPES } from './constants';\nimport { OperatorFunction } from './types';\nimport { TagPluginRegistry } from './tag-plugin-registry';\nimport { PluginContext } from './tag-plugin';\nimport { hasFunctionBody, getFunctionBody } from './ast-utils';\nimport { stringifyValue } from './utils';\nimport {\n  isMdxJsxElement,\n  isMdxJsxFlowElement,\n  isMdxJsxTextElement,\n  isParentNode,\n} from './ast-utils';\nimport { FilterRegistry } from './filter-registry';\nimport { Scope } from './scope';\nimport type { \n  Root,\n  Node, \n  Parent, \n  RootContent,\n} from 'mdast';\nimport { mdxToMarkdown } from \"mdast-util-mdx\";\nimport { toMarkdown, Options } from 'mdast-util-to-markdown';\n\njsep.plugins.register(jsepObject);\n\nconst options: Options = {\n  extensions: [mdxToMarkdown()],\n};\nconst toMdxMarkdown = (node: Root) => {\n  return toMarkdown(node, options);\n}\n\nconst nodeHelpers = {\n  isMdxJsxElement,\n  isMdxJsxFlowElement,\n  isMdxJsxTextElement,\n  isParentNode,\n  toMarkdown: toMdxMarkdown,\n  hasFunctionBody,\n  getFunctionBody,\n  NODE_TYPES,\n};\n\nexport class NodeTransformer {\n  private scope: Scope;\n\n  constructor(scope: Scope) {\n    this.scope = scope;\n  }\n\n  async transformNode(node: Node): Promise<Node | Node[]> {\n    if (\n      node.type === NODE_TYPES.MDX_TEXT_EXPRESSION ||\n      node.type === NODE_TYPES.MDX_FLOW_EXPRESSION\n    ) {\n      return this.evaluateExpressionNode(node);\n    }\n\n    if (isMdxJsxElement(node)) {\n      return await this.processMdxJsxElement(node);\n    }\n\n    if (this.isFragmentNode(node)) {\n      const processedChildren = await Promise.all(\n        (node as Parent).children.map(async (child) => {\n          const childTransformer = new NodeTransformer(this.scope);\n          const result = await childTransformer.transformNode(child);\n          return Array.isArray(result) ? result : [result];\n        })\n      );\n\n      return processedChildren.flat();\n    }\n\n    if (isParentNode(node)) {\n      const newNode = { ...node } as Parent;\n\n      const processedChildren = await Promise.all(\n        node.children.map(async (child) => {\n          const childTransformer = new NodeTransformer(this.scope);\n          const result = await childTransformer.transformNode(child);\n          return Array.isArray(result) ? result : [result];\n        })\n      );\n\n      newNode.children = processedChildren.flat() as RootContent[];\n\n      return newNode;\n    }\n\n    return node;\n  }\n\n  private isFragmentNode(node: Node): boolean {\n    return (\n      isMdxJsxElement(node) &&\n      (node.name === null ||\n        node.name === '' ||\n        node.name === 'Fragment' ||\n        node.name === 'React.Fragment')\n    );\n  }\n\n  evaluateExpressionNode(node: Node): Node {\n    const expression = (node as any).value;\n    try {\n      const evaluatedValue = this.resolveExpression(expression);\n      return {\n        type: NODE_TYPES.TEXT,\n        value: stringifyValue(evaluatedValue),\n      } as Node;\n    } catch (error: any) {\n      throw new Error(\n        `Error evaluating expression \"${expression}\": ${error.message}`\n      );\n    }\n  }\n\n  resolveExpression(expression: string): any {\n    expression = expression.trim();\n    let ast: jsep.Expression;\n    try {\n      ast = jsep(expression);\n    } catch (e) {\n      throw new Error(`Failed to parse expression: \"${expression}\"`);\n    }\n    return this.evaluateJsepExpression(ast);\n  }\n\n  evaluateJsepExpression(node: jsep.Expression): any {\n    switch (node.type) {\n      case 'BinaryExpression':\n        return this.evaluateBinaryExpression(node as jsep.BinaryExpression);\n\n      case 'UnaryExpression':\n        return this.evaluateUnaryExpression(node as jsep.UnaryExpression);\n\n      case 'Literal':\n        return (node as jsep.Literal).value;\n\n      case 'Identifier':\n        return this.resolveVariable((node as jsep.Identifier).name);\n\n      case 'MemberExpression':\n        return this.evaluateMemberExpression(node as jsep.MemberExpression);\n\n      case 'CallExpression':\n        return this.evaluateCallExpression(node as jsep.CallExpression);\n\n      case 'ArrayExpression':\n        return this.evaluateArrayExpression(node as jsep.ArrayExpression);\n\n      case 'ObjectExpression':\n        return this.evaluateObjectExpression(node as any);\n\n      default:\n        throw new Error(`Unsupported node type: ${node.type}`);\n    }\n  }\n\n  evaluateArrayExpression(node: jsep.ArrayExpression): any[] {\n    return node.elements.map((element) => this.evaluateJsepExpression(element!));\n  }\n\n  evaluateObjectExpression(node: any): object {\n    const obj: Record<string, any> = {};\n    for (const property of node.properties) {\n      let key: string;\n      if (property.key.type === 'Identifier') {\n        key = property.key.name;\n      } else if (property.key.type === 'Literal') {\n        key = property.key.value;\n      } else {\n        throw new Error(`Unsupported object key type: ${property.key.type}`);\n      }\n      const value = this.evaluateJsepExpression(property.value);\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  evaluateCallExpression(node: jsep.CallExpression): any {\n    const callee = node.callee;\n    if (callee.type !== 'Identifier') {\n      throw new Error(`Only calls to registered filters are allowed.`);\n    }\n\n    const functionName = (callee as jsep.Identifier).name;\n    const filterFunction = FilterRegistry.get(functionName);\n    if (!filterFunction) {\n      throw new Error(`Filter \"${functionName}\" is not registered.`);\n    }\n\n    const args = node.arguments.map(arg => this.evaluateJsepExpression(arg));\n    const [input, ...rest] = args;\n    return filterFunction(input, ...rest);\n  }\n\n  resolveVariable(variablePath: string): any {\n    if (!variablePath) {\n      throw new Error(`Variable path cannot be empty.`);\n    }\n\n    const parts = variablePath.split('.');\n    let value: any;\n\n    try {\n      value = this.scope.get(parts[0]);\n    } catch (error) {\n      throw new Error(`Variable \"${parts[0]}\" is not defined in the scope.`);\n    }\n\n    for (let i = 1; i < parts.length; i++) {\n      const part = parts[i];\n      if (value == null) {\n        throw new Error(\n          `Cannot access property \"${part}\" of null or undefined in \"${variablePath}\".`\n        );\n      }\n      value = value[part];\n    }\n\n    return value;\n  }\n\n  evaluateBinaryExpression(node: jsep.BinaryExpression): any {\n    const operatorFunctions: { [key: string]: OperatorFunction } = {\n      '+': (left, right) => left + this.evaluateJsepExpression(right),\n      '-': (left, right) => left - this.evaluateJsepExpression(right),\n      '*': (left, right) => left * this.evaluateJsepExpression(right),\n      '/': (left, right) => left / this.evaluateJsepExpression(right),\n      '%': (left, right) => left % this.evaluateJsepExpression(right),\n      '==': (left, right) => left == this.evaluateJsepExpression(right),\n      '!=': (left, right) => left != this.evaluateJsepExpression(right),\n      '>': (left, right) => left > this.evaluateJsepExpression(right),\n      '>=': (left, right) => left >= this.evaluateJsepExpression(right),\n      '<': (left, right) => left < this.evaluateJsepExpression(right),\n      '<=': (left, right) => left <= this.evaluateJsepExpression(right),\n      '&&': (left, right) => left && this.evaluateJsepExpression(right),\n      '||': (left, right) => left || this.evaluateJsepExpression(right),\n    };\n    const operator = node.operator;\n\n    const operation = operatorFunctions[operator];\n    if (!operation) {\n      throw new Error(`Operator \"${operator}\" is not allowed.`);\n    }\n\n    const left = this.evaluateJsepExpression(node.left);\n\n    return operation(left, node.right);\n  }\n\n  evaluateUnaryExpression(node: jsep.UnaryExpression): any {\n    const argument = this.evaluateJsepExpression(node.argument);\n    switch (node.operator) {\n      case '+':\n        return +argument;\n      case '-':\n        return -argument;\n      case '!':\n        return !argument;\n      default:\n        throw new Error(`Unsupported operator: ${node.operator}`);\n    }\n  }\n\n  evaluateMemberExpression(node: jsep.MemberExpression): any {\n    const object = this.evaluateJsepExpression(node.object);\n    const property = node.computed\n      ? this.evaluateJsepExpression(node.property)\n      : (node.property as jsep.Identifier).name;\n\n    if (object && typeof object === 'object' && property in object) {\n      if (object[property] === undefined) return '';\n      return object[property];\n    } else {\n      return '';\n    }\n  }\n\n  async processMdxJsxElement(\n    node: MdxJsxFlowElement | MdxJsxTextElement\n  ): Promise<Node | Node[]> {\n    try {\n      const tagName = node.name!;\n      const plugin = TagPluginRegistry.get(tagName);\n      if (plugin) {\n        const props = this.evaluateProps(node);\n        const pluginContext: PluginContext = {\n          createNodeTransformer: (scope: Scope) => new NodeTransformer(scope),\n          scope: this.scope,\n          tagName,\n          nodeHelpers,\n        };\n        const result = await plugin.transform(props, node.children, pluginContext);\n        return result;\n      } else {\n        const newNode = { ...node } as Parent;\n\n        const processedChildren = await Promise.all(\n          node.children.map(async (child) => {\n            const childTransformer = new NodeTransformer(this.scope);\n            const result = await childTransformer.transformNode(child);\n            return Array.isArray(result) ? result : [result];\n          })\n        );\n\n        newNode.children = processedChildren.flat() as RootContent[];\n        return newNode;\n      }\n    } catch (error) {\n      throw new Error(\n        `Error processing MDX JSX Element: ${(error as Error).message}`\n      );\n    }\n  }\n\n  evaluateProps(node: any): Record<string, any> {\n    const props: Record<string, any> = {};\n\n    for (const attr of node.attributes) {\n      if (attr.type === MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_ATTRIBUTE) {\n        if (attr.value === null || typeof attr.value === 'string') {\n          props[attr.name] = attr.value || '';\n        } else if (\n          attr.value.type ===\n          MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_ATTRIBUTE_VALUE_EXPRESSION\n        ) {\n          const expression = attr.value.value;\n          props[attr.name] = this.resolveExpression(expression);\n        }\n      } else if (\n        attr.type === MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_EXPRESSION_ATTRIBUTE\n      ) {\n        throw new Error(\n          `Unsupported attribute type in component <${node.name}>.`\n        );\n      }\n    }\n\n    return props;\n  }\n}\n\nexport const transformTree = async (\n  tree: Root,\n  props: Record<string, any> = {},\n  shared: Record<string, any> = {},\n): Promise<Root> => {\n  const scope = new Scope({ props }, shared);\n  const transformer = new NodeTransformer(scope);\n  const processedTree = await transformer.transformNode(tree);\n  return processedTree as Root;\n};\n","export const NODE_TYPES = {\n  MDX_JSX_FLOW_ELEMENT: 'mdxJsxFlowElement',\n  MDX_JSX_TEXT_ELEMENT: 'mdxJsxTextElement',\n  MDX_JSX_ESM: 'mdxjsEsm',\n  YAML: 'yaml',\n  MDX_TEXT_EXPRESSION: 'mdxTextExpression',\n  MDX_FLOW_EXPRESSION: 'mdxFlowExpression',\n  LIST: 'list',\n  LIST_ITEM: 'listItem',\n  TEXT: 'text',\n  PARAGRAPH: 'paragraph',\n  HTML: 'html',\n} as const;\n\nexport const MDX_JSX_ATTRIBUTE_TYPES = {\n  MDX_JSX_ATTRIBUTE: 'mdxJsxAttribute',\n  MDX_JSX_ATTRIBUTE_VALUE_EXPRESSION: 'mdxJsxAttributeValueExpression',\n  MDX_JSX_EXPRESSION_ATTRIBUTE: 'mdxJsxExpressionAttribute',\n} as const;","import { TagPlugin } from './tag-plugin';\n\nexport class TagPluginRegistry {\n  private static plugins: Map<string, TagPlugin> = new Map();\n\n  static register(plugin: TagPlugin, names: string[]): void {\n    names.forEach((name) => {\n      this.plugins.set(name, plugin);\n    });\n  }\n\n  static get(name: string): TagPlugin | undefined {\n    return this.plugins.get(name);\n  }\n\n  static getAll(): Map<string, TagPlugin> {\n    return new Map(this.plugins);\n  }\n\n  static remove(name: string): void {\n    this.plugins.delete(name);\n  }\n\n  static removeAll(): void {\n    this.plugins.clear();\n  }\n}","import { NODE_TYPES } from './constants';\nimport { unified } from 'unified';\nimport yaml from 'js-yaml';\nimport {\n  MdxJsxFlowElement,\n  MdxJsxTextElement,\n} from 'mdast-util-mdx';\nimport type {\n  Parent,\n  Node,\n  Root,\n} from 'mdast';\nimport remarkParse from 'remark-parse';\nimport remarkMdx from 'remark-mdx';\nimport remarkFrontmatter from 'remark-frontmatter';\nimport remarkStringify from 'remark-stringify';\n\nexport const createBaseProcessor = () =>\n  unified().use(remarkParse).use(remarkMdx).use(remarkFrontmatter);\n\nexport function isMdxJsxElement(\n  node: Node\n): node is MdxJsxFlowElement | MdxJsxTextElement {\n  return isMdxJsxFlowElement(node) || isMdxJsxTextElement(node);\n}\n\nexport function isMdxJsxFlowElement(node: Node): node is MdxJsxFlowElement {\n  return node.type === NODE_TYPES.MDX_JSX_FLOW_ELEMENT;\n}\n\nexport function isMdxJsxTextElement(node: Node): node is MdxJsxTextElement {\n  return node.type === NODE_TYPES.MDX_JSX_TEXT_ELEMENT;\n}\n\nexport function isParentNode(node: Node): node is Parent {\n  return 'children' in node && Array.isArray(node.children);\n}\n\nexport function compressAst(node: any): void {\n  const propertiesToDelete = [\n    'position',\n    'start',\n    'end',\n    'loc',\n    'range',\n    'data',\n    'meta',\n    'raw',\n    'extra',\n    'comments',\n  ];\n\n  for (const prop of propertiesToDelete) {\n    if (prop in node) {\n      delete node[prop];\n    }\n  }\n\n  if (Array.isArray(node.children)) {\n    for (const child of node.children) {\n      compressAst(child);\n    }\n  }\n\n  if (Array.isArray(node.attributes)) {\n    for (const attr of node.attributes) {\n      compressAst(attr);\n    }\n  }\n\n  for (const key in node) {\n    if (\n      node.hasOwnProperty(key) &&\n      typeof node[key] === 'object' &&\n      node[key] !== null\n    ) {\n      compressAst(node[key]);\n    }\n  }\n}\n\nexport const getFrontMatter = (tree: Root) => {\n  const frontmatterNode = tree.children.find(\n    (node) => node.type === NODE_TYPES.YAML\n  );\n  return yaml.load(frontmatterNode?.value || '');\n};\n\nexport function parse(mdxContent: string): Root {\n  const processor = unified().use(remarkParse).use(remarkMdx).use(remarkFrontmatter);\n  return processor.parse(mdxContent) as Root;\n}\n\nexport const stringify = (tree: Root): string => {\n  const processor = createBaseProcessor().use(remarkStringify);\n  return String(processor.stringify(tree));\n};\n\nexport function hasFunctionBody(childNode: Node): boolean {\n  if (childNode.type !== 'mdxFlowExpression') {\n    return false;\n  }\n\n  const estree = (childNode as any).data?.estree;\n\n  if (!estree || estree.body.length === 0) {\n    return false;\n  }\n\n  const expression = estree.body[0].expression;\n\n  return expression.type === 'ArrowFunctionExpression';\n}\n\nexport function getFunctionBody(\n  childNode: Node,\n): { body: Node[]; argumentNames: string[] } {\n  if (childNode.type !== 'mdxFlowExpression') {\n    throw new Error('Expected a function as the child.');\n  }\n\n  const functionCode = (childNode as any).value;\n  const estree = (childNode as any).data?.estree;\n  if (!estree || estree.body.length === 0) {\n    throw new Error('Invalid function expression.');\n  }\n\n  const functionExpression = estree.body[0].expression;\n  if (functionExpression.type !== 'ArrowFunctionExpression') {\n    throw new Error('Child must be an arrow function.');\n  }\n\n  const params = functionExpression.params;\n  const argumentNames = params.map((param: any) => {\n    if (param.type === 'Identifier') {\n      return param.name;\n    } else {\n      throw new Error('Only simple identifiers are supported as function parameters.');\n    }\n  });\n\n  if (argumentNames.length < 1) {\n    throw new Error('Function must have at least one parameter.');\n  }\n\n  const arrowIndex = functionCode.indexOf('=>');\n  if (arrowIndex === -1) {\n    throw new Error('Invalid function expression.');\n  }\n  let functionBodyCode = functionCode.substring(arrowIndex + 2).trim();\n\n  if (functionBodyCode.startsWith('(') && functionBodyCode.endsWith(')')) {\n    functionBodyCode = functionBodyCode.substring(1, functionBodyCode.length - 1).trim();\n  }\n  const functionBodyTree = parse(functionBodyCode) as Root;\n  const unwrappedNodes = unwrapFragments(functionBodyTree.children);\n\n  return { body: unwrappedNodes, argumentNames };\n}\n\nfunction unwrapFragments(nodes: Node[]): Node[] {\n  const unwrappedNodes: Node[] = [];\n\n  for (const node of nodes) {\n    if (isFragmentNode(node)) {\n      if ((node as any).children) {\n        const childNodes = unwrapFragments((node as any).children);\n        unwrappedNodes.push(...childNodes);\n      }\n    } else {\n      unwrappedNodes.push(node);\n    }\n  }\n\n  return unwrappedNodes;\n}\n\n\nfunction isFragmentNode(node: Node): boolean {\n  return (\n    node.type === NODE_TYPES.MDX_JSX_FLOW_ELEMENT &&\n    (node as any).name === null\n  );\n}\n\n\n","export function resolvePath(basePath: string, targetPath: string): string {\n  if (targetPath.startsWith('/')) {\n    return targetPath;\n  }\n\n  const baseParts = basePath.split('/').filter(Boolean);\n  const targetParts = targetPath.split('/').filter(Boolean);\n  \n  for (const part of targetParts) {\n    if (part === '.') continue;\n    if (part === '..') {\n      baseParts.pop();\n    } else {\n      baseParts.push(part);\n    }\n  }\n\n  return '/' + baseParts.join('/');\n}\n\nexport function getDirname(filePath: string): string {\n  const parts = filePath.split('/').filter(Boolean);\n  parts.pop();\n  return '/' + parts.join('/');\n}\n\nexport function cloneObject(obj: any): any {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nexport function stringifyValue(value: any): string {\n  if (Array.isArray(value)) {\n    return value.join('');\n  } else if (typeof value === 'object' && value !== null) {\n    return JSON.stringify(value);\n  } else {\n    return String(value);\n  }\n}","export type FilterFunction<Input = any, Output = any, Args extends any[] = any[]> = (\n  input: Input,\n  ...args: Args\n) => Output;\n\nexport class FilterRegistry {\n  private static filters: Map<string, FilterFunction> = new Map();\n\n  static register(name: string, filterFunction: FilterFunction): void {\n    this.filters.set(name, filterFunction);\n  }\n\n  static get(name: string): FilterFunction | undefined {\n    return this.filters.get(name);\n  }\n\n  static getAll(): Map<string, FilterFunction> {\n    return new Map(this.filters);\n  }\n\n  static remove(name: string): void {\n    this.filters.delete(name);\n  }\n\n  static removeAll(): void {\n    this.filters.clear();\n  }\n}\n","export class Scope {\n  private variables: Record<string, any>;\n  private shared: Record<string, any>;\n  private parent?: Scope;\n\n  constructor(variables: Record<string, any> = {}, shared: Record<string, any>, parent?: Scope) {\n    this.variables = variables;\n    // shared = global scope\n    this.shared = shared; \n    this.parent = parent;\n  }\n\n  get(key: string): any {\n    if (key in this.variables) {\n      return this.variables[key];\n    } else if (this.parent) {\n      return this.parent.get(key);\n    } else if (key in this.shared) {\n      return this.shared[key];\n    } else {\n      return undefined;\n    }\n  }\n\n  getLocal(key: string): any {\n    return this.variables[key];\n  }\n\n  getShared(key: string): any {\n    return this.shared[key]\n  }\n\n  setShared(key: string, value: any): void {\n    this.shared[key] = value;\n  }\n\n  setLocal(key: string, value: any): void {\n    this.variables[key] = value;\n  }\n\n  createChild(variables: Record<string, any> = {}): Scope {\n    return new Scope(variables, this.shared, this);\n  }\n}\n","/**\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle} from 'mdast-util-from-markdown'\n * @import {MdxFlowExpression, MdxTextExpression} from 'mdast-util-mdx-expression'\n * @import {Handle as ToMarkdownHandle, Options as ToMarkdownExtension, State} from 'mdast-util-to-markdown'\n * @import {Parents} from 'mdast'\n */\n\nimport {ok as assert} from 'devlop'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable MDX expressions\n * in markdown.\n *\n * When using the micromark syntax extension with `addResult`, nodes will have\n * a `data.estree` field set to an ESTree `Program` node.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable MDX expressions.\n */\nexport function mdxExpressionFromMarkdown() {\n  return {\n    enter: {\n      mdxFlowExpression: enterMdxFlowExpression,\n      mdxTextExpression: enterMdxTextExpression\n    },\n    exit: {\n      mdxFlowExpression: exitMdxExpression,\n      mdxFlowExpressionChunk: exitMdxExpressionData,\n      mdxTextExpression: exitMdxExpression,\n      mdxTextExpressionChunk: exitMdxExpressionData\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable MDX expressions\n * in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable MDX expressions.\n */\nexport function mdxExpressionToMarkdown() {\n  return {\n    handlers: {\n      mdxFlowExpression: handleMdxExpression,\n      mdxTextExpression: handleMdxExpression\n    },\n    unsafe: [\n      {character: '{', inConstruct: ['phrasing']},\n      {atBreak: true, character: '{'}\n    ]\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterMdxFlowExpression(token) {\n  this.enter({type: 'mdxFlowExpression', value: ''}, token)\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterMdxTextExpression(token) {\n  this.enter({type: 'mdxTextExpression', value: ''}, token)\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitMdxExpression(token) {\n  const value = this.resume()\n  const estree = token.estree\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression')\n  this.exit(token)\n  node.value = value\n\n  if (estree) {\n    node.data = {estree}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitMdxExpressionData(token) {\n  this.config.enter.data.call(this, token)\n  this.config.exit.data.call(this, token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {MdxFlowExpression | MdxTextExpression} node\n *   Node.\n * @param {Parents | undefined} parent\n *   Parent, if any.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized markdown.\n */\nfunction handleMdxExpression(node, parent, state) {\n  const value = node.value || ''\n  const result = state.indentLines(value, function (line, index, blank) {\n    // Tab-size to eat has to be the same as what we serialize as.\n    // While in some places in markdown that’s 4, in JS it’s more common as 2.\n    // Which is what’s also in `mdast-util-mdx-jsx`:\n    // <https://github.com/syntax-tree/mdast-util-mdx-jsx/blob/40b951b/lib/index.js#L52>\n    return (index === 0 || blank ? '' : '  ') + line\n  })\n  return '{' + result + '}'\n}\n","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","/**\n * @typedef CoreOptions\n * @property {ReadonlyArray<string>} [subset=[]]\n *   Whether to only escape the given subset of characters.\n * @property {boolean} [escapeOnly=false]\n *   Whether to only escape possibly dangerous characters.\n *   Those characters are `\"`, `&`, `'`, `<`, `>`, and `` ` ``.\n *\n * @typedef FormatOptions\n * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format\n *   Format strategy.\n *\n * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions\n */\n\nconst defaultSubsetRegex = /[\"&'<>`]/g\nconst surrogatePairsRegex = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g\nconst controlCharactersRegex =\n  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\n  /[\\x01-\\t\\v\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g\nconst regexEscapeRegex = /[|\\\\{}()[\\]^$+*?.]/g\n\n/** @type {WeakMap<ReadonlyArray<string>, RegExp>} */\nconst subsetToRegexCache = new WeakMap()\n\n/**\n * Encode certain characters in `value`.\n *\n * @param {string} value\n * @param {CoreWithFormatOptions} options\n * @returns {string}\n */\nexport function core(value, options) {\n  value = value.replace(\n    options.subset\n      ? charactersToExpressionCached(options.subset)\n      : defaultSubsetRegex,\n    basic\n  )\n\n  if (options.subset || options.escapeOnly) {\n    return value\n  }\n\n  return (\n    value\n      // Surrogate pairs.\n      .replace(surrogatePairsRegex, surrogate)\n      // BMP control characters (C0 except for LF, CR, SP; DEL; and some more\n      // non-ASCII ones).\n      .replace(controlCharactersRegex, basic)\n  )\n\n  /**\n   * @param {string} pair\n   * @param {number} index\n   * @param {string} all\n   */\n  function surrogate(pair, index, all) {\n    return options.format(\n      (pair.charCodeAt(0) - 0xd800) * 0x400 +\n        pair.charCodeAt(1) -\n        0xdc00 +\n        0x10000,\n      all.charCodeAt(index + 2),\n      options\n    )\n  }\n\n  /**\n   * @param {string} character\n   * @param {number} index\n   * @param {string} all\n   */\n  function basic(character, index, all) {\n    return options.format(\n      character.charCodeAt(0),\n      all.charCodeAt(index + 1),\n      options\n    )\n  }\n}\n\n/**\n * A wrapper function that caches the result of `charactersToExpression` with a WeakMap.\n * This can improve performance when tooling calls `charactersToExpression` repeatedly\n * with the same subset.\n *\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpressionCached(subset) {\n  let cached = subsetToRegexCache.get(subset)\n\n  if (!cached) {\n    cached = charactersToExpression(subset)\n    subsetToRegexCache.set(subset, cached)\n  }\n\n  return cached\n}\n\n/**\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpression(subset) {\n  /** @type {Array<string>} */\n  const groups = []\n  let index = -1\n\n  while (++index < subset.length) {\n    groups.push(subset[index].replace(regexEscapeRegex, '\\\\$&'))\n  }\n\n  return new RegExp('(?:' + groups.join('|') + ')', 'g')\n}\n","/**\n * The smallest way to encode a character.\n *\n * @param {number} code\n * @returns {string}\n */\nexport function formatBasic(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n","/**\n * @typedef {import('./core.js').CoreOptions & import('./util/format-smart.js').FormatSmartOptions} Options\n * @typedef {import('./core.js').CoreOptions} LightOptions\n */\n\nimport {core} from './core.js'\nimport {formatSmart} from './util/format-smart.js'\nimport {formatBasic} from './util/format-basic.js'\n\n/**\n * Encode special characters in `value`.\n *\n * @param {string} value\n *   Value to encode.\n * @param {Options} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntities(value, options) {\n  return core(value, Object.assign({format: formatSmart}, options))\n}\n\n/**\n * Encode special characters in `value` as hexadecimals.\n *\n * @param {string} value\n *   Value to encode.\n * @param {LightOptions} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntitiesLight(value, options) {\n  return core(value, Object.assign({format: formatBasic}, options))\n}\n","/**\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, OnEnterError, OnExitError, Token} from 'mdast-util-from-markdown'\n * @import {Handle as ToMarkdownHandle, Options as ToMarkdownExtension, State, Tracker} from 'mdast-util-to-markdown'\n * @import {Point} from 'unist'\n * @import {MdxJsxAttribute, MdxJsxAttributeValueExpression, MdxJsxExpressionAttribute, MdxJsxFlowElement, MdxJsxTextElement} from '../index.js'\n */\n\n/**\n * @typedef Tag\n *   Single tag.\n * @property {string | undefined} name\n *   Name of tag, or `undefined` for fragment.\n *\n *   > 👉 **Note**: `null` is used in the AST for fragments, as it serializes in\n *   > JSON.\n * @property {Array<MdxJsxAttribute | MdxJsxExpressionAttribute>} attributes\n *   Attributes.\n * @property {boolean} close\n *   Whether the tag is closing (`</x>`).\n * @property {boolean} selfClosing\n *   Whether the tag is self-closing (`<x/>`).\n * @property {Token['start']} start\n *   Start point.\n * @property {Token['start']} end\n *   End point.\n *\n * @typedef ToMarkdownOptions\n *   Configuration.\n * @property {'\"' | \"'\" | null | undefined} [quote='\"']\n *   Preferred quote to use around attribute values (default: `'\"'`).\n * @property {boolean | null | undefined} [quoteSmart=false]\n *   Use the other quote if that results in less bytes (default: `false`).\n * @property {boolean | null | undefined} [tightSelfClosing=false]\n *   Do not use an extra space when closing self-closing elements: `<img/>`\n *   instead of `<img />` (default: `false`).\n * @property {number | null | undefined} [printWidth=Infinity]\n *   Try and wrap syntax at this width (default: `Infinity`).\n *\n *   When set to a finite number (say, `80`), the formatter will print\n *   attributes on separate lines when a tag doesn’t fit on one line.\n *   The normal behavior is to print attributes with spaces between them\n *   instead of line endings.\n */\n\nimport {ccount} from 'ccount'\nimport {ok as assert} from 'devlop'\nimport {parseEntities} from 'parse-entities'\nimport {stringifyEntitiesLight} from 'stringify-entities'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nimport {VFileMessage} from 'vfile-message'\n\nconst indent = '  '\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable MDX JSX.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable MDX JSX.\n *\n *   When using the syntax extension with `addResult`, nodes will have a\n *   `data.estree` field set to an ESTree `Program` node.\n */\nexport function mdxJsxFromMarkdown() {\n  return {\n    canContainEols: ['mdxJsxTextElement'],\n    enter: {\n      mdxJsxFlowTag: enterMdxJsxTag,\n      mdxJsxFlowTagClosingMarker: enterMdxJsxTagClosingMarker,\n      mdxJsxFlowTagAttribute: enterMdxJsxTagAttribute,\n      mdxJsxFlowTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,\n      mdxJsxFlowTagAttributeValueLiteral: buffer,\n      mdxJsxFlowTagAttributeValueExpression: buffer,\n      mdxJsxFlowTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker,\n\n      mdxJsxTextTag: enterMdxJsxTag,\n      mdxJsxTextTagClosingMarker: enterMdxJsxTagClosingMarker,\n      mdxJsxTextTagAttribute: enterMdxJsxTagAttribute,\n      mdxJsxTextTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,\n      mdxJsxTextTagAttributeValueLiteral: buffer,\n      mdxJsxTextTagAttributeValueExpression: buffer,\n      mdxJsxTextTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker\n    },\n    exit: {\n      mdxJsxFlowTagClosingMarker: exitMdxJsxTagClosingMarker,\n      mdxJsxFlowTagNamePrimary: exitMdxJsxTagNamePrimary,\n      mdxJsxFlowTagNameMember: exitMdxJsxTagNameMember,\n      mdxJsxFlowTagNameLocal: exitMdxJsxTagNameLocal,\n      mdxJsxFlowTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,\n      mdxJsxFlowTagExpressionAttributeValue: data,\n      mdxJsxFlowTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,\n      mdxJsxFlowTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,\n      mdxJsxFlowTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,\n      mdxJsxFlowTagAttributeValueLiteralValue: data,\n      mdxJsxFlowTagAttributeValueExpression:\n        exitMdxJsxTagAttributeValueExpression,\n      mdxJsxFlowTagAttributeValueExpressionValue: data,\n      mdxJsxFlowTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,\n      mdxJsxFlowTag: exitMdxJsxTag,\n\n      mdxJsxTextTagClosingMarker: exitMdxJsxTagClosingMarker,\n      mdxJsxTextTagNamePrimary: exitMdxJsxTagNamePrimary,\n      mdxJsxTextTagNameMember: exitMdxJsxTagNameMember,\n      mdxJsxTextTagNameLocal: exitMdxJsxTagNameLocal,\n      mdxJsxTextTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,\n      mdxJsxTextTagExpressionAttributeValue: data,\n      mdxJsxTextTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,\n      mdxJsxTextTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,\n      mdxJsxTextTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,\n      mdxJsxTextTagAttributeValueLiteralValue: data,\n      mdxJsxTextTagAttributeValueExpression:\n        exitMdxJsxTagAttributeValueExpression,\n      mdxJsxTextTagAttributeValueExpressionValue: data,\n      mdxJsxTextTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,\n      mdxJsxTextTag: exitMdxJsxTag\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function buffer() {\n    this.buffer()\n  }\n\n  /**\n   * Copy a point-like value.\n   *\n   * @param {Point} d\n   *   Point-like value.\n   * @returns {Point}\n   *   unist point.\n   */\n  function point(d) {\n    return {line: d.line, column: d.column, offset: d.offset}\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function data(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMdxJsxTag(token) {\n    /** @type {Tag} */\n    const tag = {\n      name: undefined,\n      attributes: [],\n      close: false,\n      selfClosing: false,\n      start: token.start,\n      end: token.end\n    }\n    if (!this.data.mdxJsxTagStack) this.data.mdxJsxTagStack = []\n    this.data.mdxJsxTag = tag\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMdxJsxTagClosingMarker(token) {\n    const stack = this.data.mdxJsxTagStack\n    assert(stack, 'expected `mdxJsxTagStack`')\n\n    if (stack.length === 0) {\n      throw new VFileMessage(\n        'Unexpected closing slash `/` in tag, expected an open tag first',\n        {start: token.start, end: token.end},\n        'mdast-util-mdx-jsx:unexpected-closing-slash'\n      )\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMdxJsxTagAnyAttribute(token) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n\n    if (tag.close) {\n      throw new VFileMessage(\n        'Unexpected attribute in closing tag, expected the end of the tag',\n        {start: token.start, end: token.end},\n        'mdast-util-mdx-jsx:unexpected-attribute'\n      )\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMdxJsxTagSelfClosingMarker(token) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n\n    if (tag.close) {\n      throw new VFileMessage(\n        'Unexpected self-closing slash `/` in closing tag, expected the end of the tag',\n        {start: token.start, end: token.end},\n        'mdast-util-mdx-jsx:unexpected-self-closing-slash'\n      )\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagClosingMarker() {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n    tag.close = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagNamePrimary(token) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n    tag.name = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagNameMember(token) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n    tag.name += '.' + this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagNameLocal(token) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n    tag.name += ':' + this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMdxJsxTagAttribute(token) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n    enterMdxJsxTagAnyAttribute.call(this, token)\n    tag.attributes.push({\n      type: 'mdxJsxAttribute',\n      name: '',\n      value: null,\n      position: {\n        start: point(token.start),\n        // @ts-expect-error: `end` will be patched later.\n        end: undefined\n      }\n    })\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMdxJsxTagExpressionAttribute(token) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n    enterMdxJsxTagAnyAttribute.call(this, token)\n    tag.attributes.push({type: 'mdxJsxExpressionAttribute', value: ''})\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagExpressionAttribute(token) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n    const tail = tag.attributes[tag.attributes.length - 1]\n    assert(tail.type === 'mdxJsxExpressionAttribute')\n    const estree = token.estree\n\n    tail.value = this.resume()\n\n    if (estree) {\n      tail.data = {estree}\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagAttributeNamePrimary(token) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n    const node = tag.attributes[tag.attributes.length - 1]\n    assert(node.type === 'mdxJsxAttribute')\n    node.name = this.sliceSerialize(token)\n    assert(node.position !== undefined)\n    node.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagAttributeNameLocal(token) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n    const node = tag.attributes[tag.attributes.length - 1]\n    assert(node.type === 'mdxJsxAttribute')\n    node.name += ':' + this.sliceSerialize(token)\n    assert(node.position !== undefined)\n    node.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagAttributeValueLiteral(token) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n    const node = tag.attributes[tag.attributes.length - 1]\n    node.value = parseEntities(this.resume(), {nonTerminated: false})\n    assert(node.position !== undefined)\n    node.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagAttributeValueExpression(token) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n    const tail = tag.attributes[tag.attributes.length - 1]\n    assert(tail.type === 'mdxJsxAttribute')\n    /** @type {MdxJsxAttributeValueExpression} */\n    const node = {type: 'mdxJsxAttributeValueExpression', value: this.resume()}\n    const estree = token.estree\n\n    if (estree) {\n      node.data = {estree}\n    }\n\n    tail.value = node\n    assert(tail.position !== undefined)\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTagSelfClosingMarker() {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n\n    tag.selfClosing = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMdxJsxTag(token) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n    const stack = this.data.mdxJsxTagStack\n    assert(stack, 'expected `mdxJsxTagStack`')\n    const tail = stack[stack.length - 1]\n\n    if (tag.close && tail.name !== tag.name) {\n      throw new VFileMessage(\n        'Unexpected closing tag `' +\n          serializeAbbreviatedTag(tag) +\n          '`, expected corresponding closing tag for `' +\n          serializeAbbreviatedTag(tail) +\n          '` (' +\n          stringifyPosition(tail) +\n          ')',\n        {start: token.start, end: token.end},\n        'mdast-util-mdx-jsx:end-tag-mismatch'\n      )\n    }\n\n    // End of a tag, so drop the buffer.\n    this.resume()\n\n    if (tag.close) {\n      stack.pop()\n    } else {\n      this.enter(\n        {\n          type:\n            token.type === 'mdxJsxTextTag'\n              ? 'mdxJsxTextElement'\n              : 'mdxJsxFlowElement',\n          name: tag.name || null,\n          attributes: tag.attributes,\n          children: []\n        },\n        token,\n        onErrorRightIsTag\n      )\n    }\n\n    if (tag.selfClosing || tag.close) {\n      this.exit(token, onErrorLeftIsTag)\n    } else {\n      stack.push(tag)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {OnEnterError}\n   */\n  function onErrorRightIsTag(closing, open) {\n    const stack = this.data.mdxJsxTagStack\n    assert(stack, 'expected `mdxJsxTagStack`')\n    const tag = stack[stack.length - 1]\n    assert(tag, 'expected `mdxJsxTag`')\n    const place = closing ? ' before the end of `' + closing.type + '`' : ''\n    const position = closing\n      ? {start: closing.start, end: closing.end}\n      : undefined\n\n    throw new VFileMessage(\n      'Expected a closing tag for `' +\n        serializeAbbreviatedTag(tag) +\n        '` (' +\n        stringifyPosition({start: open.start, end: open.end}) +\n        ')' +\n        place,\n      position,\n      'mdast-util-mdx-jsx:end-tag-mismatch'\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {OnExitError}\n   */\n  function onErrorLeftIsTag(a, b) {\n    const tag = this.data.mdxJsxTag\n    assert(tag, 'expected `mdxJsxTag`')\n\n    throw new VFileMessage(\n      'Expected the closing tag `' +\n        serializeAbbreviatedTag(tag) +\n        '` either after the end of `' +\n        b.type +\n        '` (' +\n        stringifyPosition(b.end) +\n        ') or another opening tag after the start of `' +\n        b.type +\n        '` (' +\n        stringifyPosition(b.start) +\n        ')',\n      {start: a.start, end: a.end},\n      'mdast-util-mdx-jsx:end-tag-mismatch'\n    )\n  }\n\n  /**\n   * Serialize a tag, excluding attributes.\n   * `self-closing` is not supported, because we don’t need it yet.\n   *\n   * @param {Tag} tag\n   * @returns {string}\n   */\n  function serializeAbbreviatedTag(tag) {\n    return '<' + (tag.close ? '/' : '') + (tag.name || '') + '>'\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable MDX JSX.\n *\n * This extension configures `mdast-util-to-markdown` with\n * `options.fences: true` and `options.resourceLink: true` too, do not\n * overwrite them!\n *\n * @param {ToMarkdownOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable MDX JSX.\n */\nexport function mdxJsxToMarkdown(options) {\n  const options_ = options || {}\n  const quote = options_.quote || '\"'\n  const quoteSmart = options_.quoteSmart || false\n  const tightSelfClosing = options_.tightSelfClosing || false\n  const printWidth = options_.printWidth || Number.POSITIVE_INFINITY\n  const alternative = quote === '\"' ? \"'\" : '\"'\n\n  if (quote !== '\"' && quote !== \"'\") {\n    throw new Error(\n      'Cannot serialize attribute values with `' +\n        quote +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  mdxElement.peek = peekElement\n\n  return {\n    handlers: {\n      mdxJsxFlowElement: mdxElement,\n      mdxJsxTextElement: mdxElement\n    },\n    unsafe: [\n      {character: '<', inConstruct: ['phrasing']},\n      {atBreak: true, character: '<'}\n    ],\n    // Always generate fenced code (never indented code).\n    fences: true,\n    // Always generate links with resources (never autolinks).\n    resourceLink: true\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n   */\n  // eslint-disable-next-line complexity\n  function mdxElement(node, _, state, info) {\n    const flow = node.type === 'mdxJsxFlowElement'\n    const selfClosing = node.name\n      ? !node.children || node.children.length === 0\n      : false\n    const depth = inferDepth(state)\n    const currentIndent = createIndent(depth)\n    const trackerOneLine = state.createTracker(info)\n    const trackerMultiLine = state.createTracker(info)\n    /** @type {Array<string>} */\n    const serializedAttributes = []\n    const prefix = (flow ? currentIndent : '') + '<' + (node.name || '')\n    const exit = state.enter(node.type)\n\n    trackerOneLine.move(prefix)\n    trackerMultiLine.move(prefix)\n\n    // None.\n    if (node.attributes && node.attributes.length > 0) {\n      if (!node.name) {\n        throw new Error('Cannot serialize fragment w/ attributes')\n      }\n\n      let index = -1\n      while (++index < node.attributes.length) {\n        const attribute = node.attributes[index]\n        /** @type {string} */\n        let result\n\n        if (attribute.type === 'mdxJsxExpressionAttribute') {\n          result = '{' + (attribute.value || '') + '}'\n        } else {\n          if (!attribute.name) {\n            throw new Error('Cannot serialize attribute w/o name')\n          }\n\n          const value = attribute.value\n          const left = attribute.name\n          /** @type {string} */\n          let right = ''\n\n          if (value === null || value === undefined) {\n            // Empty.\n          } else if (typeof value === 'object') {\n            right = '{' + (value.value || '') + '}'\n          } else {\n            // If the alternative is less common than `quote`, switch.\n            const appliedQuote =\n              quoteSmart && ccount(value, quote) > ccount(value, alternative)\n                ? alternative\n                : quote\n            right =\n              appliedQuote +\n              stringifyEntitiesLight(value, {subset: [appliedQuote]}) +\n              appliedQuote\n          }\n\n          result = left + (right ? '=' : '') + right\n        }\n\n        serializedAttributes.push(result)\n      }\n    }\n\n    let attributesOnTheirOwnLine = false\n    const attributesOnOneLine = serializedAttributes.join(' ')\n\n    if (\n      // Block:\n      flow &&\n      // Including a line ending (expressions).\n      (/\\r?\\n|\\r/.test(attributesOnOneLine) ||\n        // Current position (including `<tag`).\n        trackerOneLine.current().now.column +\n          // -1 because columns, +1 for ` ` before attributes.\n          // Attributes joined by spaces.\n          attributesOnOneLine.length +\n          // ` />`.\n          (selfClosing ? (tightSelfClosing ? 2 : 3) : 1) >\n          printWidth)\n    ) {\n      attributesOnTheirOwnLine = true\n    }\n\n    let tracker = trackerOneLine\n    let value = prefix\n\n    if (attributesOnTheirOwnLine) {\n      tracker = trackerMultiLine\n\n      let index = -1\n\n      while (++index < serializedAttributes.length) {\n        // Only indent first line of of attributes, we can’t indent attribute\n        // values.\n        serializedAttributes[index] =\n          currentIndent + indent + serializedAttributes[index]\n      }\n\n      value += tracker.move(\n        '\\n' + serializedAttributes.join('\\n') + '\\n' + currentIndent\n      )\n    } else if (attributesOnOneLine) {\n      value += tracker.move(' ' + attributesOnOneLine)\n    }\n\n    if (selfClosing) {\n      value += tracker.move(\n        (tightSelfClosing || attributesOnTheirOwnLine ? '' : ' ') + '/'\n      )\n    }\n\n    value += tracker.move('>')\n\n    if (node.children && node.children.length > 0) {\n      if (node.type === 'mdxJsxTextElement') {\n        value += tracker.move(\n          // @ts-expect-error: `containerPhrasing` is typed correctly, but TS\n          // generates *hardcoded* types, which means that our dynamically added\n          // directives are not present.\n          // At some point, TS should fix that, and `from-markdown` should be fine.\n          state.containerPhrasing(node, {\n            ...tracker.current(),\n            before: '>',\n            after: '<'\n          })\n        )\n      } else {\n        tracker.shift(2)\n        value += tracker.move('\\n')\n        value += tracker.move(containerFlow(node, state, tracker.current()))\n        value += tracker.move('\\n')\n      }\n    }\n\n    if (!selfClosing) {\n      value += tracker.move(\n        (flow ? currentIndent : '') + '</' + (node.name || '') + '>'\n      )\n    }\n\n    exit()\n    return value\n  }\n}\n\n// Modified copy of:\n// <https://github.com/syntax-tree/mdast-util-to-markdown/blob/a381cbc/lib/util/container-flow.js>.\n//\n// To do: add `indent` support to `mdast-util-to-markdown`.\n// As indents are only used for JSX, it’s fine for now, but perhaps better\n// there.\n/**\n * @param {MdxJsxFlowElement} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {ReturnType<Tracker['current']>} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children\n  const tracker = state.createTracker(info)\n  const currentIndent = createIndent(inferDepth(state))\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    const childInfo = {before: '\\n', after: '\\n', ...tracker.current()}\n\n    const result = state.handle(child, parent, state, childInfo)\n\n    const serializedChild =\n      child.type === 'mdxJsxFlowElement'\n        ? result\n        : state.indentLines(result, function (line, _, blank) {\n            return (blank ? '' : currentIndent) + line\n          })\n\n    results.push(tracker.move(serializedChild))\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(tracker.move('\\n\\n'))\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {State} state\n * @returns {number}\n */\nfunction inferDepth(state) {\n  let depth = 0\n  let index = state.stack.length\n\n  while (--index > -1) {\n    const name = state.stack[index]\n\n    if (name === 'blockquote' || name === 'listItem') break\n    if (name === 'mdxJsxFlowElement') depth++\n  }\n\n  return depth\n}\n\n/**\n * @param {number} depth\n * @returns {string}\n */\nfunction createIndent(depth) {\n  return indent.repeat(depth)\n}\n\n/**\n * @type {ToMarkdownHandle}\n */\nfunction peekElement() {\n  return '<'\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n *\n * @typedef {import('../index.js').MdxjsEsm} MdxjsEsm\n */\n\n// To do: next major: expose functions.\nimport {ok as assert} from 'devlop'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable MDX.js ESM in\n * markdown.\n *\n * When using the micromark syntax extension with `addResult`, nodes will have\n * a `data.estree` field set to an ESTree [`Program`][program] node.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable MDX.js ESM.\n */\nexport function mdxjsEsmFromMarkdown() {\n  return {\n    enter: {mdxjsEsm: enterMdxjsEsm},\n    exit: {mdxjsEsm: exitMdxjsEsm, mdxjsEsmData: exitMdxjsEsmData}\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable MDX.js ESM in\n * markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable MDX.js ESM.\n */\nexport function mdxjsEsmToMarkdown() {\n  return {handlers: {mdxjsEsm: handleMdxjsEsm}}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterMdxjsEsm(token) {\n  this.enter({type: 'mdxjsEsm', value: ''}, token)\n  this.buffer() // Capture EOLs\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitMdxjsEsm(token) {\n  const value = this.resume()\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'mdxjsEsm')\n\n  this.exit(token)\n\n  const estree = token.estree\n\n  node.value = value\n\n  if (estree) {\n    node.data = {estree}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitMdxjsEsmData(token) {\n  this.config.enter.data.call(this, token)\n  this.config.exit.data.call(this, token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {MdxjsEsm} node\n */\nfunction handleMdxjsEsm(node) {\n  return node.value || ''\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-mdx-jsx').ToMarkdownOptions} ToMarkdownOptions\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\nimport {\n  mdxExpressionFromMarkdown,\n  mdxExpressionToMarkdown\n} from 'mdast-util-mdx-expression'\nimport {mdxJsxFromMarkdown, mdxJsxToMarkdown} from 'mdast-util-mdx-jsx'\nimport {mdxjsEsmFromMarkdown, mdxjsEsmToMarkdown} from 'mdast-util-mdxjs-esm'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable MDX (ESM, JSX,\n * expressions).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable MDX (ESM, JSX,\n *   expressions).\n *\n *   When using the syntax extensions with `addResult`, ESM and expression\n *   nodes will have `data.estree` fields set to ESTree `Program` node.\n */\nexport function mdxFromMarkdown() {\n  return [\n    mdxExpressionFromMarkdown(),\n    mdxJsxFromMarkdown(),\n    mdxjsEsmFromMarkdown()\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable MDX (ESM, JSX,\n * expressions).\n *\n * @param {ToMarkdownOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable MDX (ESM, JSX,\n *   expressions).\n */\nexport function mdxToMarkdown(options) {\n  return {\n    extensions: [\n      mdxExpressionToMarkdown(),\n      mdxJsxToMarkdown(options),\n      mdxjsEsmToMarkdown()\n    ]\n  }\n}\n","import { NODE_TYPES, MDX_JSX_ATTRIBUTE_TYPES } from './constants';\nimport { getDirname, resolvePath, cloneObject } from './utils';\nimport { visit } from 'unist-util-visit';\nimport type { Root, RootContent, Paragraph, Parent, Node } from 'mdast';\nimport type { ComponentASTs, ContentLoader } from './types';\nimport { SKIP } from 'unist-util-visit';\nimport {\n  isMdxJsxElement,\n  isParentNode,\n  parse,\n} from './ast-utils';\n\nexport async function bundle(\n  mdxContent: string,\n  baseDir: string,\n  contentLoader: ContentLoader\n): Promise<Root> {\n  const processedFiles = new Set<string>();\n  const mainAbsolutePath = resolvePath(baseDir, '__PROMPTDX_IGNORE__.mdx');\n\n  const { tree: mainTree, componentASTs } = await processMdxContent(\n    mdxContent,\n    mainAbsolutePath,\n    new Set(),\n    processedFiles,\n    contentLoader\n  );\n\n  await inlineComponents(mainTree, componentASTs);\n\n  return mainTree;\n}\n\nasync function processMdxContent(\n  content: string,\n  absolutePath: string,\n  callStack: Set<string>,\n  processedFiles: Set<string>,\n  contentLoader: ContentLoader\n): Promise<{ tree: Root; componentASTs: ComponentASTs }> {\n  if (processedFiles.has(absolutePath)) {\n    return { tree: { type: 'root', children: [] }, componentASTs: {} };\n  }\n\n  if (callStack.has(absolutePath)) {\n    throw new Error(\n      `Circular import detected: ${[...callStack, absolutePath].join(' -> ')}`\n    );\n  }\n\n  callStack.add(absolutePath);\n\n  const tree = parse(content);\n  removeComments(tree);\n  const imports = extractImports(tree, absolutePath);\n  const componentASTs: ComponentASTs = {};\n\n  for (const [componentName, sourcePath] of Object.entries(imports)) {\n    const importAbsolutePath = resolvePath(getDirname(absolutePath), sourcePath);\n    const importedContent = await contentLoader(importAbsolutePath);\n\n    const { tree: componentTree, componentASTs: nestedComponentASTs } =\n      await processMdxContent(\n        importedContent,\n        importAbsolutePath,\n        new Set(callStack),\n        processedFiles,\n        contentLoader\n      );\n\n    Object.assign(componentASTs, nestedComponentASTs);\n    componentASTs[componentName] = componentTree.children;\n  }\n\n  tree.children = tree.children.filter(\n    (node: any) => node.type !== NODE_TYPES.MDX_JSX_ESM\n  );\n  processedFiles.add(absolutePath);\n  callStack.delete(absolutePath);\n\n  return { tree, componentASTs };\n}\n\nfunction removeComments(tree: Root): void {\n  visit(tree, (node, index, parent) => {\n    if (isCommentNode(node) && parent) {\n      parent.children.splice(index!, 1);\n      return [SKIP, index];\n    }\n  });\n}\n\nfunction isCommentNode(node: Node): boolean {\n  if (\n    node.type === NODE_TYPES.MDX_FLOW_EXPRESSION ||\n    node.type === NODE_TYPES.MDX_TEXT_EXPRESSION\n  ) {\n    const value = (node as any).value.trim();\n    return (\n      (value.startsWith('/*') && value.endsWith('*/')) ||\n      value.startsWith('//')\n    );\n  }\n  return false;\n}\n\nfunction extractImports(tree: Root, absolutePath: string): Record<string, string> {\n  const imports: Record<string, string> = {};\n\n  visit(tree, NODE_TYPES.MDX_JSX_ESM, (node: any) => {\n    const estree = node.data?.estree;\n\n    if (!estree) {\n      throw new Error(`No ESTree found in ${absolutePath}`);\n    }\n\n    for (const stmt of estree.body) {\n      if (stmt.type === 'ImportDeclaration') {\n        const defaultSpecifier = stmt.specifiers.find(\n          (spec: any) => spec.type === 'ImportDefaultSpecifier'\n        );\n\n        if (\n          stmt.specifiers.some(\n            (spec: any) => spec.type !== 'ImportDefaultSpecifier'\n          )\n        ) {\n          throw new Error(\n            `Only default imports are supported. Invalid import in ${absolutePath}: ${node.value.trim()}`\n          );\n        }\n\n        if (defaultSpecifier) {\n          const importedName = defaultSpecifier.local.name;\n          const source = stmt.source.value as string;\n          imports[importedName] = source;\n        } else {\n          throw new Error(\n            `Invalid import in ${absolutePath}: ${node.value.trim()}`\n          );\n        }\n      } else if (stmt.type.startsWith('Export')) {\n        throw new Error(\n          `Exports are not supported. Found in ${absolutePath}: ${node.value.trim()}`\n        );\n      }\n    }\n  });\n\n  return imports;\n}\n\nasync function inlineComponents(\n  tree: Root,\n  componentASTs: ComponentASTs\n): Promise<void> {\n  let hasReplacements: boolean;\n\n  do {\n    hasReplacements = inlineJsxElements(tree, componentASTs);\n  } while (hasReplacements);\n}\n\nfunction inlineJsxElements(\n  tree: Root | Parent,\n  componentASTs: ComponentASTs,\n  parentProps: Record<string, any> = {}\n): boolean {\n  let replaced = false;\n\n  visit(\n    tree,\n    [NODE_TYPES.MDX_JSX_FLOW_ELEMENT, NODE_TYPES.MDX_JSX_TEXT_ELEMENT],\n    (node: any, index, parent) => {\n      const componentName = node.name;\n      if (componentASTs[componentName]) {\n        const componentNodes = cloneObject(componentASTs[componentName]);\n        const props = extractRawProps(node, parentProps);\n        const childrenContent = node.children || [];\n\n        const processedComponentNodes = componentNodes.map((childNode: any) =>\n          inlineComponentsAndResolveProps(\n            childNode,\n            props,\n            childrenContent,\n            componentASTs\n          )\n        );\n\n        parent.children.splice(index, 1, ...processedComponentNodes.flat());\n        replaced = true;\n      }\n    }\n  );\n\n  return replaced;\n}\n\nfunction extractRawProps(\n  node: any,\n  parentProps: Record<string, any>\n): Record<string, any> {\n  const props: Record<string, any> = {};\n\n  for (const attr of node.attributes) {\n    if (attr.type === MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_ATTRIBUTE) {\n      if (attr.value === null || typeof attr.value === 'string') {\n        props[attr.name] = JSON.stringify(attr.value || '');\n      } else if (attr.value.type === MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_ATTRIBUTE_VALUE_EXPRESSION) {\n        const { value: resolvedValue } = substitutePropsInExpression(\n          attr.value.value,\n          parentProps\n        );\n        props[attr.name] = resolvedValue;\n      }\n    } else if (attr.type === MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_EXPRESSION_ATTRIBUTE) {\n      throw new Error(\n        `Only literal attribute values are supported. Invalid attribute in component <${node.name}>.`\n      );\n    }\n  }\n\n  return props;\n}\n\nfunction substitutePropsInExpression(\n  expression: string,\n  props: Record<string, any>,\n): { value: string; isLiteral: boolean } {\n  const propRegex = /props\\.(\\w+)/g;\n  const visitedProps = new Set();\n  let currentExpression = expression;\n\n  const substitute = (expr: string): string => {\n    return expr.replace(propRegex, (match, propName) => {\n      if (visitedProps.has(propName)) {\n        throw new Error(`Circular reference detected for property '${propName}'.`);\n      }\n      if (props.hasOwnProperty(propName)) {\n        visitedProps.add(propName);\n        const propValue = props[propName];\n        if (typeof propValue === 'string') {\n          return substitute(propValue);\n        } else {\n          return String(propValue);\n        }\n      } else {\n        return match;\n      }\n    });\n  };\n\n  try {\n    currentExpression = substitute(currentExpression);\n  } catch (error) {\n    throw new Error(`Error substituting props in expression: ${(error as Error).message}`);\n  }\n\n  const isLiteral = /^['\"].*['\"]$|^\\d+(\\.\\d+)?$/.test(currentExpression);\n\n  return { value: currentExpression, isLiteral };\n}\n\nfunction inlineComponentsAndResolveProps(\n  node: Node,\n  props: Record<string, any>,\n  childrenContent: RootContent[],\n  componentASTs: ComponentASTs\n): Node | Node[] {\n  if (\n    node.type === NODE_TYPES.MDX_TEXT_EXPRESSION ||\n    node.type === NODE_TYPES.MDX_FLOW_EXPRESSION\n  ) {\n    if ((node as any).value === 'props.children') {\n      const childrenTree: Root = { type: 'root', children: [...childrenContent] };\n      inlineComponents(childrenTree, componentASTs);\n      return combinedNodesIntoParagraph(childrenTree.children);\n    } else if ((node as any).value.includes('props.')) {\n      const { value: resolvedValue, isLiteral } = substitutePropsInExpression(\n        (node as any).value,\n        props\n      );\n\n      if (isLiteral) {\n        return {\n          type: NODE_TYPES.TEXT,\n          value: JSON.parse(resolvedValue),\n        } as Node;\n      } else {\n        return {\n          type: node.type,\n          value: resolvedValue,\n        } as Node;\n      }\n    }\n  }\n\n  if (isMdxJsxElement(node)) {\n    const componentName = node.name!;\n    if (componentASTs[componentName]) {\n      const componentNodes = cloneObject(componentASTs[componentName]);\n      const newProps = extractRawProps(node, props);\n      const childrenContent = node.children || [];\n\n      const processedComponentNodes = componentNodes.map((childNode: any) =>\n        inlineComponentsAndResolveProps(\n          childNode,\n          newProps,\n          childrenContent,\n          componentASTs\n        )\n      );\n\n      return processedComponentNodes.flat();\n    }\n  }\n\n  if (isParentNode(node)) {\n    const newNode = node as Parent;\n    newNode.children = newNode.children.flatMap((child) =>\n      inlineComponentsAndResolveProps(\n        child,\n        props,\n        childrenContent,\n        componentASTs\n      )\n    ) as RootContent[];\n  }\n\n  return node;\n}\n\nfunction combinedNodesIntoParagraph(nodes: RootContent[]): RootContent[] {\n  const contentChildren: RootContent[] = [];\n\n  nodes.forEach((node, index) => {\n    if (node.type === NODE_TYPES.PARAGRAPH || node.type === NODE_TYPES.LIST) {\n      contentChildren.push(...(node as Parent).children);\n    } else {\n      contentChildren.push(node);\n    }\n\n    if (index !== nodes.length - 1) {\n      contentChildren.push({ type: NODE_TYPES.TEXT, value: '\\n' });\n    }\n  });\n\n  if (contentChildren.length > 0) {\n    return [\n      {\n        type: NODE_TYPES.PARAGRAPH,\n        children: contentChildren,\n      } as Paragraph,\n    ];\n  }\n\n  return [];\n}\n","import { Node } from 'mdast';\nimport { Scope } from './scope';\nimport { NODE_TYPES } from './constants';\n\nexport interface NodeHelpers {\n  isMdxJsxElement(node: Node): boolean;\n  isMdxJsxFlowElement(node: Node): boolean;\n  isMdxJsxTextElement(node: Node): boolean;\n  isParentNode(node: Node): boolean;\n  toMarkdown(node: Node): string;\n  hasFunctionBody(node: Node): boolean;\n  getFunctionBody(node: Node): { body: Node[]; argumentNames: string[] };\n  NODE_TYPES: typeof NODE_TYPES;\n}\n\nexport interface PluginContext {\n  nodeHelpers: NodeHelpers;\n  createNodeTransformer: (scope: Scope) => any;\n  scope: Scope;\n  tagName: string;\n}\n\nexport abstract class TagPlugin<Props = Record<string, any>> {\n  abstract transform(\n    props: Props,\n    children: Node[],\n    context: PluginContext\n  ): Promise<Node[] | Node>;\n}\n","import { Node, Parent } from 'mdast';\nimport { TagPlugin, PluginContext } from '../tag-plugin';\n\nexport const Tags = ['ForEach'];\n\nexport interface ForEachProps<T = any> {\n  children: (item: T, index: number) => any;\n  arr: Array<T>;\n}\n\nexport class ForEachPlugin extends TagPlugin {\n  async transform(\n    props: Record<string, any>,\n    children: Node[],\n    context: PluginContext\n  ): Promise<Node[] | Node> {\n    const {\n      scope,\n      createNodeTransformer,\n      nodeHelpers\n    } = context;\n\n    const { hasFunctionBody, getFunctionBody, NODE_TYPES } = nodeHelpers;\n\n    function areAllListItems(resultNodesPerItem: Node[][]): boolean {\n      return resultNodesPerItem.every((processedNodes) =>\n        processedNodes.every(\n          (n: Node) =>\n            n.type === NODE_TYPES.LIST || n.type === NODE_TYPES.LIST_ITEM\n        )\n      );\n    }\n\n    function collectListItems(resultNodesPerItem: Node[][]): Node[] {\n      return resultNodesPerItem.flatMap((processedNodes) =>\n        processedNodes.flatMap((n: Node) => {\n          if (n.type === NODE_TYPES.LIST) {\n            return (n as Parent).children;\n          } else if (n.type === NODE_TYPES.LIST_ITEM) {\n            return n;\n          } else {\n            return [];\n          }\n        })\n      );\n    }\n\n\n    if (children.length !== 1) {\n      throw new Error(`ForEach expects exactly one child function.`);\n    }\n    const childNode = children[0];\n    if (!hasFunctionBody(childNode)) {\n      throw new Error('ForEach expects a function as its child.');\n    }\n    const { body, argumentNames } = getFunctionBody(childNode);\n    const arr = props['arr'];\n    if (!Array.isArray(arr)) {\n      throw new Error(`The 'arr' prop for <ForEach> must be an array.`);\n    }\n\n    const itemParamName = argumentNames[0];\n    const indexParamName = argumentNames[1];\n    const resultNodesPerItem = await Promise.all(\n      arr.map(async (item: any, index: number) => {\n        const itemScope = scope.createChild({\n          ...(itemParamName && { [itemParamName]: item }),\n          ...(indexParamName && { [indexParamName]: index }),\n        });\n        const itemTransformer = createNodeTransformer(itemScope);\n        const processedChildren = await Promise.all(\n          body.map(async (child) => {\n            const result = await itemTransformer.transformNode(child);\n            return Array.isArray(result) ? result : [result];\n          })\n        );\n        return processedChildren.flat();\n      })\n    );\n    const resultNodes = resultNodesPerItem.flat();\n    if (areAllListItems(resultNodesPerItem)) {\n      return [\n        {\n          type: NODE_TYPES.LIST,\n          ordered: false,\n          spread: false,\n          children: collectListItems(resultNodesPerItem),\n        } as Node,\n      ];\n    } else {\n      return resultNodes;\n    }\n  }\n}\n","import { Node } from \"mdast\";\nimport { TagPlugin, PluginContext } from \"../tag-plugin\";\n\nexport interface IfProps {\n  condition: boolean;\n  children: any;\n}\n\nexport interface ElseIfProps {\n  condition: boolean;\n  children: any;\n}\n\nexport interface ElseProps {\n  children: any;\n}\n\nexport const Tags = ['If', 'ElseIf', 'Else'];\n\nexport class ConditionalPlugin extends TagPlugin {\n  async transform(\n    props: Record<string, any>,\n    children: Node[],\n    context: PluginContext\n  ): Promise<Node[] | Node> {\n    const { scope, createNodeTransformer, tagName } = context;\n\n    if (!tagName) {\n      throw new Error(\"The 'tagName' must be provided in the context.\");\n    }\n\n    let conditionMet = scope.getLocal(\"conditionMet\");\n    if (conditionMet === undefined) {\n      scope.setLocal(\"conditionMet\", false);\n      conditionMet = false;\n    }\n\n    if (conditionMet) {\n      return [];\n    }\n\n    let shouldRender = false;\n\n    if (tagName === \"If\" || tagName === \"ElseIf\") {\n      const condition = props[\"condition\"];\n      if (typeof condition !== \"boolean\") {\n        throw new Error(\n          `The 'condition' prop for <${tagName}> must be a boolean.`\n        );\n      }\n      if (condition) {\n        shouldRender = true;\n      }\n    } else if (tagName === \"Else\") {\n      shouldRender = true;\n    } else {\n      throw new Error(`Unsupported element type: ${tagName}`);\n    }\n\n    if (shouldRender) {\n      scope.setLocal(\"conditionMet\", true);\n      const childScope = scope.createChild();\n      const transformer = createNodeTransformer(childScope);\n\n      const results: Node[] = [];\n      for (const child of children) {\n        const transformed = await transformer.transformNode(child);\n        if (Array.isArray(transformed)) {\n          results.push(...transformed);\n        } else if (transformed) {\n          results.push(transformed);\n        }\n      }\n\n      return results;\n    }\n\n    return [];\n  }\n}\n","import { Node, Root } from \"mdast\";\nimport { TagPlugin, PluginContext } from \"../tag-plugin\";\n\nexport interface RawProps {\n  children: any;\n}\n\nexport const Tags = ['Raw'];\n\nexport class RawPlugin extends TagPlugin {\n  async transform(\n    _props: Record<string, any>,\n    children: Node[],\n    context: PluginContext\n  ): Promise<Node[] | Node> {\n    const { nodeHelpers } = context;\n    const rawContent = nodeHelpers.toMarkdown({\n        type: 'root',\n        children: children,\n    } as Root);\n    return [\n      {\n        type: 'text',\n        value: rawContent,\n      } as Node,\n    ];\n  }\n}","import { FilterFunction } from '../filter-registry';\n\nexport interface Filters {\n  capitalize: FilterFunction<string, string>;\n  upper: FilterFunction<string, string>;\n  lower: FilterFunction<string, string>;\n  truncate: FilterFunction<string, string, [number]>;\n  abs: FilterFunction<number, number>;\n  join: FilterFunction<any[], string, [string?]>;\n  round: FilterFunction<number, number, [number?]>;\n  replace: FilterFunction<string, string, [string, string]>;\n  urlencode: FilterFunction<string, string>;\n  dump: FilterFunction<any, string>;\n}\n\nexport const capitalize: Filters['capitalize'] = (input) => {\n  if (typeof input !== \"string\") return input;\n  return input.charAt(0).toUpperCase() + input.slice(1);\n};\n\nexport const upper: Filters['upper'] = (input) => {\n  if (typeof input !== \"string\") return input;\n  return input.toUpperCase();\n};\n\nexport const lower: Filters['lower']= (input) => {\n  if (typeof input !== \"string\") return input;\n  return input.toLowerCase();\n};\n\nexport const truncate: Filters['truncate'] = (input, length) => {\n  if (typeof input !== \"string\") return input;\n  if (input.length <= length) return input;\n  return input.substring(0, length) + \"...\";\n};\n\nexport const abs: Filters['abs'] = (input) => {\n  return Math.abs(input);\n};\n\nexport const join: Filters['join'] = (input, separator = \", \") => {\n  if (!Array.isArray(input)) return input;\n  return input.join(separator);\n};\n\nexport const round: Filters['round'] = (input, decimals = 0) => {\n  return Number(Math.round(Number(input + \"e\" + decimals)) + \"e-\" + decimals);\n};\n\nexport const replace: Filters['replace'] = (input, search, replace) => {\n  if (typeof input !== \"string\") return input;\n  return input.split(search).join(replace);\n};\n\nexport const urlencode: Filters['urlencode']= (input) => {\n  if (typeof input !== \"string\") return input;\n  return encodeURIComponent(input);\n};\n\nexport const dump: Filters['dump'] = (input) => {\n  return JSON.stringify(input);\n};\n","import { ForEachPlugin, Tags as ForEachTags } from './tag-plugins/for-each';\nimport { ConditionalPlugin, Tags as ConditionalTags } from './tag-plugins/conditional';\nimport { RawPlugin, Tags as RawTags } from './tag-plugins/raw';\nimport { TagPluginRegistry } from './tag-plugin-registry';\n\nimport { FilterRegistry } from \"./filter-registry\";\nimport {\n  capitalize,\n  upper,\n  lower,\n  truncate,\n  abs,\n  join,\n  round,\n  replace,\n  urlencode,\n  dump,\n} from \"./filter-plugins\";\n\n\nTagPluginRegistry.register(new ForEachPlugin(), ForEachTags);\nTagPluginRegistry.register(new ConditionalPlugin(), ConditionalTags);\nTagPluginRegistry.register(new RawPlugin(), RawTags);\n\nFilterRegistry.register(\"capitalize\", capitalize);\nFilterRegistry.register(\"upper\", upper);\nFilterRegistry.register(\"lower\", lower);\nFilterRegistry.register(\"truncate\", truncate);\nFilterRegistry.register(\"abs\", abs);\nFilterRegistry.register(\"join\", join);\nFilterRegistry.register(\"round\", round);\nFilterRegistry.register(\"replace\", replace);\nFilterRegistry.register(\"urlencode\", urlencode);\nFilterRegistry.register(\"dump\", dump)","import { transformTree } from \"./transformer\";\nimport { bundle } from \"./bundler\";\nimport {\n  compressAst,\n  stringify,\n  getFrontMatter,\n} from \"./ast-utils\";\nimport { TagPluginRegistry } from \"./tag-plugin-registry\";\nimport { TagPlugin, PluginContext } from \"./tag-plugin\";\nimport { FilterRegistry } from \"./filter-registry\";\nimport type { FilterFunction } from \"./filter-registry\";\nimport type { ContentLoader } from \"./types\";\nimport type { Root } from \"mdast\";\nimport { getDirname } from \"./utils\";\nimport type { BaseMDXProvidedComponents } from './types';\nimport './global.d';\nimport './register-builtin-plugins';\n\nconst readFile = async (path: string) => {\n  // @ts-ignore\n  if (typeof Deno !== 'undefined') {\n    // @ts-ignore\n    return await Deno.readTextFile(path);\n  } else if (typeof require !== 'undefined') {\n    const { readFile } = await import('fs/promises');\n    return await readFile(path, 'utf8');\n  } else {\n    throw new Error('Unsupported environment');\n  }\n};\n\nasync function load (path: string) {\n  const file = await readFile(path);\n  const componentLoader = async (path: string) => readFile(path);\n  return bundle(file, getDirname(path), componentLoader);\n}\n\nexport type {\n  ContentLoader,\n  Root as Ast,\n  PluginContext,\n  FilterFunction,\n  BaseMDXProvidedComponents\n};\nexport {\n  stringify,\n  bundle as parse,\n  getFrontMatter,\n  compressAst,\n  load,\n  transformTree as transform,\n  TagPluginRegistry,\n  TagPlugin,\n  FilterRegistry\n};"],"mappings":"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","names":["options","options","options","value","options","left","childrenContent","nodeHelpers","hasFunctionBody","getFunctionBody","NODE_TYPES","resultNodesPerItem","Tags","Tags","nodeHelpers","replace","Tags","readFile","path"]}