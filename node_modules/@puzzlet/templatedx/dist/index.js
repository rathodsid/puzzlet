var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/transformer.ts
import jsep from "jsep";
import jsepObject from "@jsep-plugin/object";

// src/constants.ts
var NODE_TYPES = {
  MDX_JSX_FLOW_ELEMENT: "mdxJsxFlowElement",
  MDX_JSX_TEXT_ELEMENT: "mdxJsxTextElement",
  MDX_JSX_ESM: "mdxjsEsm",
  YAML: "yaml",
  MDX_TEXT_EXPRESSION: "mdxTextExpression",
  MDX_FLOW_EXPRESSION: "mdxFlowExpression",
  LIST: "list",
  LIST_ITEM: "listItem",
  TEXT: "text",
  PARAGRAPH: "paragraph",
  HTML: "html"
};
var MDX_JSX_ATTRIBUTE_TYPES = {
  MDX_JSX_ATTRIBUTE: "mdxJsxAttribute",
  MDX_JSX_ATTRIBUTE_VALUE_EXPRESSION: "mdxJsxAttributeValueExpression",
  MDX_JSX_EXPRESSION_ATTRIBUTE: "mdxJsxExpressionAttribute"
};

// src/tag-plugin-registry.ts
var TagPluginRegistry = class {
  static register(plugin, names) {
    names.forEach((name) => {
      this.plugins.set(name, plugin);
    });
  }
  static get(name) {
    return this.plugins.get(name);
  }
  static getAll() {
    return new Map(this.plugins);
  }
  static remove(name) {
    this.plugins.delete(name);
  }
  static removeAll() {
    this.plugins.clear();
  }
};
TagPluginRegistry.plugins = /* @__PURE__ */ new Map();

// src/ast-utils.ts
import { unified } from "unified";
import yaml from "js-yaml";
import remarkParse from "remark-parse";
import remarkMdx from "remark-mdx";
import remarkFrontmatter from "remark-frontmatter";
import remarkStringify from "remark-stringify";
var createBaseProcessor = () => unified().use(remarkParse).use(remarkMdx).use(remarkFrontmatter);
function isMdxJsxElement(node) {
  return isMdxJsxFlowElement(node) || isMdxJsxTextElement(node);
}
function isMdxJsxFlowElement(node) {
  return node.type === NODE_TYPES.MDX_JSX_FLOW_ELEMENT;
}
function isMdxJsxTextElement(node) {
  return node.type === NODE_TYPES.MDX_JSX_TEXT_ELEMENT;
}
function isParentNode(node) {
  return "children" in node && Array.isArray(node.children);
}
function compressAst(node) {
  const propertiesToDelete = [
    "position",
    "start",
    "end",
    "loc",
    "range",
    "data",
    "meta",
    "raw",
    "extra",
    "comments"
  ];
  for (const prop of propertiesToDelete) {
    if (prop in node) {
      delete node[prop];
    }
  }
  if (Array.isArray(node.children)) {
    for (const child of node.children) {
      compressAst(child);
    }
  }
  if (Array.isArray(node.attributes)) {
    for (const attr of node.attributes) {
      compressAst(attr);
    }
  }
  for (const key in node) {
    if (node.hasOwnProperty(key) && typeof node[key] === "object" && node[key] !== null) {
      compressAst(node[key]);
    }
  }
}
var getFrontMatter = (tree) => {
  const frontmatterNode = tree.children.find(
    (node) => node.type === NODE_TYPES.YAML
  );
  return yaml.load((frontmatterNode == null ? void 0 : frontmatterNode.value) || "");
};
function parse(mdxContent) {
  const processor = unified().use(remarkParse).use(remarkMdx).use(remarkFrontmatter);
  return processor.parse(mdxContent);
}
var stringify = (tree) => {
  const processor = createBaseProcessor().use(remarkStringify);
  return String(processor.stringify(tree));
};
function hasFunctionBody(childNode) {
  var _a;
  if (childNode.type !== "mdxFlowExpression") {
    return false;
  }
  const estree = (_a = childNode.data) == null ? void 0 : _a.estree;
  if (!estree || estree.body.length === 0) {
    return false;
  }
  const expression = estree.body[0].expression;
  return expression.type === "ArrowFunctionExpression";
}
function getFunctionBody(childNode) {
  var _a;
  if (childNode.type !== "mdxFlowExpression") {
    throw new Error("Expected a function as the child.");
  }
  const functionCode = childNode.value;
  const estree = (_a = childNode.data) == null ? void 0 : _a.estree;
  if (!estree || estree.body.length === 0) {
    throw new Error("Invalid function expression.");
  }
  const functionExpression = estree.body[0].expression;
  if (functionExpression.type !== "ArrowFunctionExpression") {
    throw new Error("Child must be an arrow function.");
  }
  const params = functionExpression.params;
  const argumentNames = params.map((param) => {
    if (param.type === "Identifier") {
      return param.name;
    } else {
      throw new Error("Only simple identifiers are supported as function parameters.");
    }
  });
  if (argumentNames.length < 1) {
    throw new Error("Function must have at least one parameter.");
  }
  const arrowIndex = functionCode.indexOf("=>");
  if (arrowIndex === -1) {
    throw new Error("Invalid function expression.");
  }
  let functionBodyCode = functionCode.substring(arrowIndex + 2).trim();
  if (functionBodyCode.startsWith("(") && functionBodyCode.endsWith(")")) {
    functionBodyCode = functionBodyCode.substring(1, functionBodyCode.length - 1).trim();
  }
  const functionBodyTree = parse(functionBodyCode);
  const unwrappedNodes = unwrapFragments(functionBodyTree.children);
  return { body: unwrappedNodes, argumentNames };
}
function unwrapFragments(nodes) {
  const unwrappedNodes = [];
  for (const node of nodes) {
    if (isFragmentNode(node)) {
      if (node.children) {
        const childNodes = unwrapFragments(node.children);
        unwrappedNodes.push(...childNodes);
      }
    } else {
      unwrappedNodes.push(node);
    }
  }
  return unwrappedNodes;
}
function isFragmentNode(node) {
  return node.type === NODE_TYPES.MDX_JSX_FLOW_ELEMENT && node.name === null;
}

// src/utils.ts
function resolvePath(basePath, targetPath) {
  if (targetPath.startsWith("/")) {
    return targetPath;
  }
  const baseParts = basePath.split("/").filter(Boolean);
  const targetParts = targetPath.split("/").filter(Boolean);
  for (const part of targetParts) {
    if (part === ".") continue;
    if (part === "..") {
      baseParts.pop();
    } else {
      baseParts.push(part);
    }
  }
  return "/" + baseParts.join("/");
}
function getDirname(filePath) {
  const parts = filePath.split("/").filter(Boolean);
  parts.pop();
  return "/" + parts.join("/");
}
function cloneObject(obj) {
  return JSON.parse(JSON.stringify(obj));
}
function stringifyValue(value) {
  if (Array.isArray(value)) {
    return value.join("");
  } else if (typeof value === "object" && value !== null) {
    return JSON.stringify(value);
  } else {
    return String(value);
  }
}

// src/filter-registry.ts
var FilterRegistry = class {
  static register(name, filterFunction) {
    this.filters.set(name, filterFunction);
  }
  static get(name) {
    return this.filters.get(name);
  }
  static getAll() {
    return new Map(this.filters);
  }
  static remove(name) {
    this.filters.delete(name);
  }
  static removeAll() {
    this.filters.clear();
  }
};
FilterRegistry.filters = /* @__PURE__ */ new Map();

// src/scope.ts
var Scope = class _Scope {
  constructor(variables = {}, shared, parent) {
    this.variables = variables;
    this.shared = shared;
    this.parent = parent;
  }
  get(key) {
    if (key in this.variables) {
      return this.variables[key];
    } else if (this.parent) {
      return this.parent.get(key);
    } else if (key in this.shared) {
      return this.shared[key];
    } else {
      return void 0;
    }
  }
  getLocal(key) {
    return this.variables[key];
  }
  getShared(key) {
    return this.shared[key];
  }
  setShared(key, value) {
    this.shared[key] = value;
  }
  setLocal(key, value) {
    this.variables[key] = value;
  }
  createChild(variables = {}) {
    return new _Scope(variables, this.shared, this);
  }
};

// node_modules/mdast-util-mdx-expression/lib/index.js
function mdxExpressionToMarkdown() {
  return {
    handlers: {
      mdxFlowExpression: handleMdxExpression,
      mdxTextExpression: handleMdxExpression
    },
    unsafe: [
      { character: "{", inConstruct: ["phrasing"] },
      { atBreak: true, character: "{" }
    ]
  };
}
function handleMdxExpression(node, parent, state) {
  const value = node.value || "";
  const result = state.indentLines(value, function(line, index, blank) {
    return (index === 0 || blank ? "" : "  ") + line;
  });
  return "{" + result + "}";
}

// node_modules/ccount/index.js
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index = source.indexOf(character);
  while (index !== -1) {
    count++;
    index = source.indexOf(character, index + character.length);
  }
  return count;
}

// node_modules/stringify-entities/lib/core.js
var defaultSubsetRegex = /["&'<>`]/g;
var surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var controlCharactersRegex = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
);
var regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g;
var subsetToRegexCache = /* @__PURE__ */ new WeakMap();
function core(value, options2) {
  value = value.replace(
    options2.subset ? charactersToExpressionCached(options2.subset) : defaultSubsetRegex,
    basic
  );
  if (options2.subset || options2.escapeOnly) {
    return value;
  }
  return value.replace(surrogatePairsRegex, surrogate).replace(controlCharactersRegex, basic);
  function surrogate(pair, index, all) {
    return options2.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all.charCodeAt(index + 2),
      options2
    );
  }
  function basic(character, index, all) {
    return options2.format(
      character.charCodeAt(0),
      all.charCodeAt(index + 1),
      options2
    );
  }
}
function charactersToExpressionCached(subset) {
  let cached = subsetToRegexCache.get(subset);
  if (!cached) {
    cached = charactersToExpression(subset);
    subsetToRegexCache.set(subset, cached);
  }
  return cached;
}
function charactersToExpression(subset) {
  const groups = [];
  let index = -1;
  while (++index < subset.length) {
    groups.push(subset[index].replace(regexEscapeRegex, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}

// node_modules/stringify-entities/lib/util/format-basic.js
function formatBasic(code) {
  return "&#x" + code.toString(16).toUpperCase() + ";";
}

// node_modules/stringify-entities/lib/index.js
function stringifyEntitiesLight(value, options2) {
  return core(value, Object.assign({ format: formatBasic }, options2));
}

// node_modules/mdast-util-mdx-jsx/lib/index.js
var indent = "  ";
function mdxJsxToMarkdown(options2) {
  const options_ = options2 || {};
  const quote = options_.quote || '"';
  const quoteSmart = options_.quoteSmart || false;
  const tightSelfClosing = options_.tightSelfClosing || false;
  const printWidth = options_.printWidth || Number.POSITIVE_INFINITY;
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error(
      "Cannot serialize attribute values with `" + quote + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  mdxElement.peek = peekElement;
  return {
    handlers: {
      mdxJsxFlowElement: mdxElement,
      mdxJsxTextElement: mdxElement
    },
    unsafe: [
      { character: "<", inConstruct: ["phrasing"] },
      { atBreak: true, character: "<" }
    ],
    // Always generate fenced code (never indented code).
    fences: true,
    // Always generate links with resources (never autolinks).
    resourceLink: true
  };
  function mdxElement(node, _, state, info) {
    const flow = node.type === "mdxJsxFlowElement";
    const selfClosing = node.name ? !node.children || node.children.length === 0 : false;
    const depth = inferDepth(state);
    const currentIndent = createIndent(depth);
    const trackerOneLine = state.createTracker(info);
    const trackerMultiLine = state.createTracker(info);
    const serializedAttributes = [];
    const prefix = (flow ? currentIndent : "") + "<" + (node.name || "");
    const exit = state.enter(node.type);
    trackerOneLine.move(prefix);
    trackerMultiLine.move(prefix);
    if (node.attributes && node.attributes.length > 0) {
      if (!node.name) {
        throw new Error("Cannot serialize fragment w/ attributes");
      }
      let index = -1;
      while (++index < node.attributes.length) {
        const attribute = node.attributes[index];
        let result;
        if (attribute.type === "mdxJsxExpressionAttribute") {
          result = "{" + (attribute.value || "") + "}";
        } else {
          if (!attribute.name) {
            throw new Error("Cannot serialize attribute w/o name");
          }
          const value2 = attribute.value;
          const left = attribute.name;
          let right = "";
          if (value2 === null || value2 === void 0) {
          } else if (typeof value2 === "object") {
            right = "{" + (value2.value || "") + "}";
          } else {
            const appliedQuote = quoteSmart && ccount(value2, quote) > ccount(value2, alternative) ? alternative : quote;
            right = appliedQuote + stringifyEntitiesLight(value2, { subset: [appliedQuote] }) + appliedQuote;
          }
          result = left + (right ? "=" : "") + right;
        }
        serializedAttributes.push(result);
      }
    }
    let attributesOnTheirOwnLine = false;
    const attributesOnOneLine = serializedAttributes.join(" ");
    if (
      // Block:
      flow && // Including a line ending (expressions).
      (/\r?\n|\r/.test(attributesOnOneLine) || // Current position (including `<tag`).
      trackerOneLine.current().now.column + // -1 because columns, +1 for ` ` before attributes.
      // Attributes joined by spaces.
      attributesOnOneLine.length + // ` />`.
      (selfClosing ? tightSelfClosing ? 2 : 3 : 1) > printWidth)
    ) {
      attributesOnTheirOwnLine = true;
    }
    let tracker = trackerOneLine;
    let value = prefix;
    if (attributesOnTheirOwnLine) {
      tracker = trackerMultiLine;
      let index = -1;
      while (++index < serializedAttributes.length) {
        serializedAttributes[index] = currentIndent + indent + serializedAttributes[index];
      }
      value += tracker.move(
        "\n" + serializedAttributes.join("\n") + "\n" + currentIndent
      );
    } else if (attributesOnOneLine) {
      value += tracker.move(" " + attributesOnOneLine);
    }
    if (selfClosing) {
      value += tracker.move(
        (tightSelfClosing || attributesOnTheirOwnLine ? "" : " ") + "/"
      );
    }
    value += tracker.move(">");
    if (node.children && node.children.length > 0) {
      if (node.type === "mdxJsxTextElement") {
        value += tracker.move(
          // @ts-expect-error: `containerPhrasing` is typed correctly, but TS
          // generates *hardcoded* types, which means that our dynamically added
          // directives are not present.
          // At some point, TS should fix that, and `from-markdown` should be fine.
          state.containerPhrasing(node, {
            ...tracker.current(),
            before: ">",
            after: "<"
          })
        );
      } else {
        tracker.shift(2);
        value += tracker.move("\n");
        value += tracker.move(containerFlow(node, state, tracker.current()));
        value += tracker.move("\n");
      }
    }
    if (!selfClosing) {
      value += tracker.move(
        (flow ? currentIndent : "") + "</" + (node.name || "") + ">"
      );
    }
    exit();
    return value;
  }
}
function containerFlow(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children;
  const tracker = state.createTracker(info);
  const currentIndent = createIndent(inferDepth(state));
  const results = [];
  let index = -1;
  indexStack.push(-1);
  while (++index < children.length) {
    const child = children[index];
    indexStack[indexStack.length - 1] = index;
    const childInfo = { before: "\n", after: "\n", ...tracker.current() };
    const result = state.handle(child, parent, state, childInfo);
    const serializedChild = child.type === "mdxJsxFlowElement" ? result : state.indentLines(result, function(line, _, blank) {
      return (blank ? "" : currentIndent) + line;
    });
    results.push(tracker.move(serializedChild));
    if (child.type !== "list") {
      state.bulletLastUsed = void 0;
    }
    if (index < children.length - 1) {
      results.push(tracker.move("\n\n"));
    }
  }
  indexStack.pop();
  return results.join("");
}
function inferDepth(state) {
  let depth = 0;
  let index = state.stack.length;
  while (--index > -1) {
    const name = state.stack[index];
    if (name === "blockquote" || name === "listItem") break;
    if (name === "mdxJsxFlowElement") depth++;
  }
  return depth;
}
function createIndent(depth) {
  return indent.repeat(depth);
}
function peekElement() {
  return "<";
}

// node_modules/mdast-util-mdxjs-esm/lib/index.js
function mdxjsEsmToMarkdown() {
  return { handlers: { mdxjsEsm: handleMdxjsEsm } };
}
function handleMdxjsEsm(node) {
  return node.value || "";
}

// node_modules/mdast-util-mdx/lib/index.js
function mdxToMarkdown(options2) {
  return {
    extensions: [
      mdxExpressionToMarkdown(),
      mdxJsxToMarkdown(options2),
      mdxjsEsmToMarkdown()
    ]
  };
}

// src/transformer.ts
import { toMarkdown } from "mdast-util-to-markdown";
jsep.plugins.register(jsepObject);
var options = {
  extensions: [mdxToMarkdown()]
};
var toMdxMarkdown = (node) => {
  return toMarkdown(node, options);
};
var nodeHelpers = {
  isMdxJsxElement,
  isMdxJsxFlowElement,
  isMdxJsxTextElement,
  isParentNode,
  toMarkdown: toMdxMarkdown,
  hasFunctionBody,
  getFunctionBody,
  NODE_TYPES
};
var NodeTransformer = class _NodeTransformer {
  constructor(scope) {
    this.scope = scope;
  }
  async transformNode(node) {
    if (node.type === NODE_TYPES.MDX_TEXT_EXPRESSION || node.type === NODE_TYPES.MDX_FLOW_EXPRESSION) {
      return this.evaluateExpressionNode(node);
    }
    if (isMdxJsxElement(node)) {
      return await this.processMdxJsxElement(node);
    }
    if (this.isFragmentNode(node)) {
      const processedChildren = await Promise.all(
        node.children.map(async (child) => {
          const childTransformer = new _NodeTransformer(this.scope);
          const result = await childTransformer.transformNode(child);
          return Array.isArray(result) ? result : [result];
        })
      );
      return processedChildren.flat();
    }
    if (isParentNode(node)) {
      const newNode = { ...node };
      const processedChildren = await Promise.all(
        node.children.map(async (child) => {
          const childTransformer = new _NodeTransformer(this.scope);
          const result = await childTransformer.transformNode(child);
          return Array.isArray(result) ? result : [result];
        })
      );
      newNode.children = processedChildren.flat();
      return newNode;
    }
    return node;
  }
  isFragmentNode(node) {
    return isMdxJsxElement(node) && (node.name === null || node.name === "" || node.name === "Fragment" || node.name === "React.Fragment");
  }
  evaluateExpressionNode(node) {
    const expression = node.value;
    try {
      const evaluatedValue = this.resolveExpression(expression);
      return {
        type: NODE_TYPES.TEXT,
        value: stringifyValue(evaluatedValue)
      };
    } catch (error) {
      throw new Error(
        `Error evaluating expression "${expression}": ${error.message}`
      );
    }
  }
  resolveExpression(expression) {
    expression = expression.trim();
    let ast;
    try {
      ast = jsep(expression);
    } catch (e) {
      throw new Error(`Failed to parse expression: "${expression}"`);
    }
    return this.evaluateJsepExpression(ast);
  }
  evaluateJsepExpression(node) {
    switch (node.type) {
      case "BinaryExpression":
        return this.evaluateBinaryExpression(node);
      case "UnaryExpression":
        return this.evaluateUnaryExpression(node);
      case "Literal":
        return node.value;
      case "Identifier":
        return this.resolveVariable(node.name);
      case "MemberExpression":
        return this.evaluateMemberExpression(node);
      case "CallExpression":
        return this.evaluateCallExpression(node);
      case "ArrayExpression":
        return this.evaluateArrayExpression(node);
      case "ObjectExpression":
        return this.evaluateObjectExpression(node);
      default:
        throw new Error(`Unsupported node type: ${node.type}`);
    }
  }
  evaluateArrayExpression(node) {
    return node.elements.map((element) => this.evaluateJsepExpression(element));
  }
  evaluateObjectExpression(node) {
    const obj = {};
    for (const property of node.properties) {
      let key;
      if (property.key.type === "Identifier") {
        key = property.key.name;
      } else if (property.key.type === "Literal") {
        key = property.key.value;
      } else {
        throw new Error(`Unsupported object key type: ${property.key.type}`);
      }
      const value = this.evaluateJsepExpression(property.value);
      obj[key] = value;
    }
    return obj;
  }
  evaluateCallExpression(node) {
    const callee = node.callee;
    if (callee.type !== "Identifier") {
      throw new Error(`Only calls to registered filters are allowed.`);
    }
    const functionName = callee.name;
    const filterFunction = FilterRegistry.get(functionName);
    if (!filterFunction) {
      throw new Error(`Filter "${functionName}" is not registered.`);
    }
    const args = node.arguments.map((arg) => this.evaluateJsepExpression(arg));
    const [input, ...rest] = args;
    return filterFunction(input, ...rest);
  }
  resolveVariable(variablePath) {
    if (!variablePath) {
      throw new Error(`Variable path cannot be empty.`);
    }
    const parts = variablePath.split(".");
    let value;
    try {
      value = this.scope.get(parts[0]);
    } catch (error) {
      throw new Error(`Variable "${parts[0]}" is not defined in the scope.`);
    }
    for (let i = 1; i < parts.length; i++) {
      const part = parts[i];
      if (value == null) {
        throw new Error(
          `Cannot access property "${part}" of null or undefined in "${variablePath}".`
        );
      }
      value = value[part];
    }
    return value;
  }
  evaluateBinaryExpression(node) {
    const operatorFunctions = {
      "+": (left2, right) => left2 + this.evaluateJsepExpression(right),
      "-": (left2, right) => left2 - this.evaluateJsepExpression(right),
      "*": (left2, right) => left2 * this.evaluateJsepExpression(right),
      "/": (left2, right) => left2 / this.evaluateJsepExpression(right),
      "%": (left2, right) => left2 % this.evaluateJsepExpression(right),
      "==": (left2, right) => left2 == this.evaluateJsepExpression(right),
      "!=": (left2, right) => left2 != this.evaluateJsepExpression(right),
      ">": (left2, right) => left2 > this.evaluateJsepExpression(right),
      ">=": (left2, right) => left2 >= this.evaluateJsepExpression(right),
      "<": (left2, right) => left2 < this.evaluateJsepExpression(right),
      "<=": (left2, right) => left2 <= this.evaluateJsepExpression(right),
      "&&": (left2, right) => left2 && this.evaluateJsepExpression(right),
      "||": (left2, right) => left2 || this.evaluateJsepExpression(right)
    };
    const operator = node.operator;
    const operation = operatorFunctions[operator];
    if (!operation) {
      throw new Error(`Operator "${operator}" is not allowed.`);
    }
    const left = this.evaluateJsepExpression(node.left);
    return operation(left, node.right);
  }
  evaluateUnaryExpression(node) {
    const argument = this.evaluateJsepExpression(node.argument);
    switch (node.operator) {
      case "+":
        return +argument;
      case "-":
        return -argument;
      case "!":
        return !argument;
      default:
        throw new Error(`Unsupported operator: ${node.operator}`);
    }
  }
  evaluateMemberExpression(node) {
    const object = this.evaluateJsepExpression(node.object);
    const property = node.computed ? this.evaluateJsepExpression(node.property) : node.property.name;
    if (object && typeof object === "object" && property in object) {
      if (object[property] === void 0) return "";
      return object[property];
    } else {
      return "";
    }
  }
  async processMdxJsxElement(node) {
    try {
      const tagName = node.name;
      const plugin = TagPluginRegistry.get(tagName);
      if (plugin) {
        const props = this.evaluateProps(node);
        const pluginContext = {
          createNodeTransformer: (scope) => new _NodeTransformer(scope),
          scope: this.scope,
          tagName,
          nodeHelpers
        };
        const result = await plugin.transform(props, node.children, pluginContext);
        return result;
      } else {
        const newNode = { ...node };
        const processedChildren = await Promise.all(
          node.children.map(async (child) => {
            const childTransformer = new _NodeTransformer(this.scope);
            const result = await childTransformer.transformNode(child);
            return Array.isArray(result) ? result : [result];
          })
        );
        newNode.children = processedChildren.flat();
        return newNode;
      }
    } catch (error) {
      throw new Error(
        `Error processing MDX JSX Element: ${error.message}`
      );
    }
  }
  evaluateProps(node) {
    const props = {};
    for (const attr of node.attributes) {
      if (attr.type === MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_ATTRIBUTE) {
        if (attr.value === null || typeof attr.value === "string") {
          props[attr.name] = attr.value || "";
        } else if (attr.value.type === MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_ATTRIBUTE_VALUE_EXPRESSION) {
          const expression = attr.value.value;
          props[attr.name] = this.resolveExpression(expression);
        }
      } else if (attr.type === MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_EXPRESSION_ATTRIBUTE) {
        throw new Error(
          `Unsupported attribute type in component <${node.name}>.`
        );
      }
    }
    return props;
  }
};
var transformTree = async (tree, props = {}, shared = {}) => {
  const scope = new Scope({ props }, shared);
  const transformer = new NodeTransformer(scope);
  const processedTree = await transformer.transformNode(tree);
  return processedTree;
};

// src/bundler.ts
import { visit } from "unist-util-visit";
import { SKIP } from "unist-util-visit";
async function bundle(mdxContent, baseDir, contentLoader) {
  const processedFiles = /* @__PURE__ */ new Set();
  const mainAbsolutePath = resolvePath(baseDir, "__PROMPTDX_IGNORE__.mdx");
  const { tree: mainTree, componentASTs } = await processMdxContent(
    mdxContent,
    mainAbsolutePath,
    /* @__PURE__ */ new Set(),
    processedFiles,
    contentLoader
  );
  await inlineComponents(mainTree, componentASTs);
  return mainTree;
}
async function processMdxContent(content, absolutePath, callStack, processedFiles, contentLoader) {
  if (processedFiles.has(absolutePath)) {
    return { tree: { type: "root", children: [] }, componentASTs: {} };
  }
  if (callStack.has(absolutePath)) {
    throw new Error(
      `Circular import detected: ${[...callStack, absolutePath].join(" -> ")}`
    );
  }
  callStack.add(absolutePath);
  const tree = parse(content);
  removeComments(tree);
  const imports = extractImports(tree, absolutePath);
  const componentASTs = {};
  for (const [componentName, sourcePath] of Object.entries(imports)) {
    const importAbsolutePath = resolvePath(getDirname(absolutePath), sourcePath);
    const importedContent = await contentLoader(importAbsolutePath);
    const { tree: componentTree, componentASTs: nestedComponentASTs } = await processMdxContent(
      importedContent,
      importAbsolutePath,
      new Set(callStack),
      processedFiles,
      contentLoader
    );
    Object.assign(componentASTs, nestedComponentASTs);
    componentASTs[componentName] = componentTree.children;
  }
  tree.children = tree.children.filter(
    (node) => node.type !== NODE_TYPES.MDX_JSX_ESM
  );
  processedFiles.add(absolutePath);
  callStack.delete(absolutePath);
  return { tree, componentASTs };
}
function removeComments(tree) {
  visit(tree, (node, index, parent) => {
    if (isCommentNode(node) && parent) {
      parent.children.splice(index, 1);
      return [SKIP, index];
    }
  });
}
function isCommentNode(node) {
  if (node.type === NODE_TYPES.MDX_FLOW_EXPRESSION || node.type === NODE_TYPES.MDX_TEXT_EXPRESSION) {
    const value = node.value.trim();
    return value.startsWith("/*") && value.endsWith("*/") || value.startsWith("//");
  }
  return false;
}
function extractImports(tree, absolutePath) {
  const imports = {};
  visit(tree, NODE_TYPES.MDX_JSX_ESM, (node) => {
    var _a;
    const estree = (_a = node.data) == null ? void 0 : _a.estree;
    if (!estree) {
      throw new Error(`No ESTree found in ${absolutePath}`);
    }
    for (const stmt of estree.body) {
      if (stmt.type === "ImportDeclaration") {
        const defaultSpecifier = stmt.specifiers.find(
          (spec) => spec.type === "ImportDefaultSpecifier"
        );
        if (stmt.specifiers.some(
          (spec) => spec.type !== "ImportDefaultSpecifier"
        )) {
          throw new Error(
            `Only default imports are supported. Invalid import in ${absolutePath}: ${node.value.trim()}`
          );
        }
        if (defaultSpecifier) {
          const importedName = defaultSpecifier.local.name;
          const source = stmt.source.value;
          imports[importedName] = source;
        } else {
          throw new Error(
            `Invalid import in ${absolutePath}: ${node.value.trim()}`
          );
        }
      } else if (stmt.type.startsWith("Export")) {
        throw new Error(
          `Exports are not supported. Found in ${absolutePath}: ${node.value.trim()}`
        );
      }
    }
  });
  return imports;
}
async function inlineComponents(tree, componentASTs) {
  let hasReplacements;
  do {
    hasReplacements = inlineJsxElements(tree, componentASTs);
  } while (hasReplacements);
}
function inlineJsxElements(tree, componentASTs, parentProps = {}) {
  let replaced = false;
  visit(
    tree,
    [NODE_TYPES.MDX_JSX_FLOW_ELEMENT, NODE_TYPES.MDX_JSX_TEXT_ELEMENT],
    (node, index, parent) => {
      const componentName = node.name;
      if (componentASTs[componentName]) {
        const componentNodes = cloneObject(componentASTs[componentName]);
        const props = extractRawProps(node, parentProps);
        const childrenContent = node.children || [];
        const processedComponentNodes = componentNodes.map(
          (childNode) => inlineComponentsAndResolveProps(
            childNode,
            props,
            childrenContent,
            componentASTs
          )
        );
        parent.children.splice(index, 1, ...processedComponentNodes.flat());
        replaced = true;
      }
    }
  );
  return replaced;
}
function extractRawProps(node, parentProps) {
  const props = {};
  for (const attr of node.attributes) {
    if (attr.type === MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_ATTRIBUTE) {
      if (attr.value === null || typeof attr.value === "string") {
        props[attr.name] = JSON.stringify(attr.value || "");
      } else if (attr.value.type === MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_ATTRIBUTE_VALUE_EXPRESSION) {
        const { value: resolvedValue } = substitutePropsInExpression(
          attr.value.value,
          parentProps
        );
        props[attr.name] = resolvedValue;
      }
    } else if (attr.type === MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_EXPRESSION_ATTRIBUTE) {
      throw new Error(
        `Only literal attribute values are supported. Invalid attribute in component <${node.name}>.`
      );
    }
  }
  return props;
}
function substitutePropsInExpression(expression, props) {
  const propRegex = /props\.(\w+)/g;
  const visitedProps = /* @__PURE__ */ new Set();
  let currentExpression = expression;
  const substitute = (expr) => {
    return expr.replace(propRegex, (match, propName) => {
      if (visitedProps.has(propName)) {
        throw new Error(`Circular reference detected for property '${propName}'.`);
      }
      if (props.hasOwnProperty(propName)) {
        visitedProps.add(propName);
        const propValue = props[propName];
        if (typeof propValue === "string") {
          return substitute(propValue);
        } else {
          return String(propValue);
        }
      } else {
        return match;
      }
    });
  };
  try {
    currentExpression = substitute(currentExpression);
  } catch (error) {
    throw new Error(`Error substituting props in expression: ${error.message}`);
  }
  const isLiteral = /^['"].*['"]$|^\d+(\.\d+)?$/.test(currentExpression);
  return { value: currentExpression, isLiteral };
}
function inlineComponentsAndResolveProps(node, props, childrenContent, componentASTs) {
  if (node.type === NODE_TYPES.MDX_TEXT_EXPRESSION || node.type === NODE_TYPES.MDX_FLOW_EXPRESSION) {
    if (node.value === "props.children") {
      const childrenTree = { type: "root", children: [...childrenContent] };
      inlineComponents(childrenTree, componentASTs);
      return combinedNodesIntoParagraph(childrenTree.children);
    } else if (node.value.includes("props.")) {
      const { value: resolvedValue, isLiteral } = substitutePropsInExpression(
        node.value,
        props
      );
      if (isLiteral) {
        return {
          type: NODE_TYPES.TEXT,
          value: JSON.parse(resolvedValue)
        };
      } else {
        return {
          type: node.type,
          value: resolvedValue
        };
      }
    }
  }
  if (isMdxJsxElement(node)) {
    const componentName = node.name;
    if (componentASTs[componentName]) {
      const componentNodes = cloneObject(componentASTs[componentName]);
      const newProps = extractRawProps(node, props);
      const childrenContent2 = node.children || [];
      const processedComponentNodes = componentNodes.map(
        (childNode) => inlineComponentsAndResolveProps(
          childNode,
          newProps,
          childrenContent2,
          componentASTs
        )
      );
      return processedComponentNodes.flat();
    }
  }
  if (isParentNode(node)) {
    const newNode = node;
    newNode.children = newNode.children.flatMap(
      (child) => inlineComponentsAndResolveProps(
        child,
        props,
        childrenContent,
        componentASTs
      )
    );
  }
  return node;
}
function combinedNodesIntoParagraph(nodes) {
  const contentChildren = [];
  nodes.forEach((node, index) => {
    if (node.type === NODE_TYPES.PARAGRAPH || node.type === NODE_TYPES.LIST) {
      contentChildren.push(...node.children);
    } else {
      contentChildren.push(node);
    }
    if (index !== nodes.length - 1) {
      contentChildren.push({ type: NODE_TYPES.TEXT, value: "\n" });
    }
  });
  if (contentChildren.length > 0) {
    return [
      {
        type: NODE_TYPES.PARAGRAPH,
        children: contentChildren
      }
    ];
  }
  return [];
}

// src/tag-plugin.ts
var TagPlugin = class {
};

// src/tag-plugins/for-each.ts
var Tags = ["ForEach"];
var ForEachPlugin = class extends TagPlugin {
  async transform(props, children, context) {
    const {
      scope,
      createNodeTransformer,
      nodeHelpers: nodeHelpers2
    } = context;
    const { hasFunctionBody: hasFunctionBody2, getFunctionBody: getFunctionBody2, NODE_TYPES: NODE_TYPES2 } = nodeHelpers2;
    function areAllListItems(resultNodesPerItem2) {
      return resultNodesPerItem2.every(
        (processedNodes) => processedNodes.every(
          (n) => n.type === NODE_TYPES2.LIST || n.type === NODE_TYPES2.LIST_ITEM
        )
      );
    }
    function collectListItems(resultNodesPerItem2) {
      return resultNodesPerItem2.flatMap(
        (processedNodes) => processedNodes.flatMap((n) => {
          if (n.type === NODE_TYPES2.LIST) {
            return n.children;
          } else if (n.type === NODE_TYPES2.LIST_ITEM) {
            return n;
          } else {
            return [];
          }
        })
      );
    }
    if (children.length !== 1) {
      throw new Error(`ForEach expects exactly one child function.`);
    }
    const childNode = children[0];
    if (!hasFunctionBody2(childNode)) {
      throw new Error("ForEach expects a function as its child.");
    }
    const { body, argumentNames } = getFunctionBody2(childNode);
    const arr = props["arr"];
    if (!Array.isArray(arr)) {
      throw new Error(`The 'arr' prop for <ForEach> must be an array.`);
    }
    const itemParamName = argumentNames[0];
    const indexParamName = argumentNames[1];
    const resultNodesPerItem = await Promise.all(
      arr.map(async (item, index) => {
        const itemScope = scope.createChild({
          ...itemParamName && { [itemParamName]: item },
          ...indexParamName && { [indexParamName]: index }
        });
        const itemTransformer = createNodeTransformer(itemScope);
        const processedChildren = await Promise.all(
          body.map(async (child) => {
            const result = await itemTransformer.transformNode(child);
            return Array.isArray(result) ? result : [result];
          })
        );
        return processedChildren.flat();
      })
    );
    const resultNodes = resultNodesPerItem.flat();
    if (areAllListItems(resultNodesPerItem)) {
      return [
        {
          type: NODE_TYPES2.LIST,
          ordered: false,
          spread: false,
          children: collectListItems(resultNodesPerItem)
        }
      ];
    } else {
      return resultNodes;
    }
  }
};

// src/tag-plugins/conditional.ts
var Tags2 = ["If", "ElseIf", "Else"];
var ConditionalPlugin = class extends TagPlugin {
  async transform(props, children, context) {
    const { scope, createNodeTransformer, tagName } = context;
    if (!tagName) {
      throw new Error("The 'tagName' must be provided in the context.");
    }
    let conditionMet = scope.getLocal("conditionMet");
    if (conditionMet === void 0) {
      scope.setLocal("conditionMet", false);
      conditionMet = false;
    }
    if (conditionMet) {
      return [];
    }
    let shouldRender = false;
    if (tagName === "If" || tagName === "ElseIf") {
      const condition = props["condition"];
      if (typeof condition !== "boolean") {
        throw new Error(
          `The 'condition' prop for <${tagName}> must be a boolean.`
        );
      }
      if (condition) {
        shouldRender = true;
      }
    } else if (tagName === "Else") {
      shouldRender = true;
    } else {
      throw new Error(`Unsupported element type: ${tagName}`);
    }
    if (shouldRender) {
      scope.setLocal("conditionMet", true);
      const childScope = scope.createChild();
      const transformer = createNodeTransformer(childScope);
      const results = [];
      for (const child of children) {
        const transformed = await transformer.transformNode(child);
        if (Array.isArray(transformed)) {
          results.push(...transformed);
        } else if (transformed) {
          results.push(transformed);
        }
      }
      return results;
    }
    return [];
  }
};

// src/tag-plugins/raw.ts
var Tags3 = ["Raw"];
var RawPlugin = class extends TagPlugin {
  async transform(_props, children, context) {
    const { nodeHelpers: nodeHelpers2 } = context;
    const rawContent = nodeHelpers2.toMarkdown({
      type: "root",
      children
    });
    return [
      {
        type: "text",
        value: rawContent
      }
    ];
  }
};

// src/filter-plugins/index.ts
var capitalize = (input) => {
  if (typeof input !== "string") return input;
  return input.charAt(0).toUpperCase() + input.slice(1);
};
var upper = (input) => {
  if (typeof input !== "string") return input;
  return input.toUpperCase();
};
var lower = (input) => {
  if (typeof input !== "string") return input;
  return input.toLowerCase();
};
var truncate = (input, length) => {
  if (typeof input !== "string") return input;
  if (input.length <= length) return input;
  return input.substring(0, length) + "...";
};
var abs = (input) => {
  return Math.abs(input);
};
var join = (input, separator = ", ") => {
  if (!Array.isArray(input)) return input;
  return input.join(separator);
};
var round = (input, decimals = 0) => {
  return Number(Math.round(Number(input + "e" + decimals)) + "e-" + decimals);
};
var replace = (input, search, replace2) => {
  if (typeof input !== "string") return input;
  return input.split(search).join(replace2);
};
var urlencode = (input) => {
  if (typeof input !== "string") return input;
  return encodeURIComponent(input);
};
var dump = (input) => {
  return JSON.stringify(input);
};

// src/register-builtin-plugins.ts
TagPluginRegistry.register(new ForEachPlugin(), Tags);
TagPluginRegistry.register(new ConditionalPlugin(), Tags2);
TagPluginRegistry.register(new RawPlugin(), Tags3);
FilterRegistry.register("capitalize", capitalize);
FilterRegistry.register("upper", upper);
FilterRegistry.register("lower", lower);
FilterRegistry.register("truncate", truncate);
FilterRegistry.register("abs", abs);
FilterRegistry.register("join", join);
FilterRegistry.register("round", round);
FilterRegistry.register("replace", replace);
FilterRegistry.register("urlencode", urlencode);
FilterRegistry.register("dump", dump);

// src/index.ts
var readFile = async (path) => {
  if (typeof Deno !== "undefined") {
    return await Deno.readTextFile(path);
  } else if (typeof __require !== "undefined") {
    const { readFile: readFile2 } = await import("fs/promises");
    return await readFile2(path, "utf8");
  } else {
    throw new Error("Unsupported environment");
  }
};
async function load(path) {
  const file = await readFile(path);
  const componentLoader = async (path2) => readFile(path2);
  return bundle(file, getDirname(path), componentLoader);
}
export {
  FilterRegistry,
  TagPlugin,
  TagPluginRegistry,
  compressAst,
  getFrontMatter,
  load,
  bundle as parse,
  stringify,
  transformTree as transform
};
//# sourceMappingURL=index.js.map