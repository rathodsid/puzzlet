import { Root, Node } from 'mdast';
export { Root as Ast } from 'mdast';

declare class Scope {
    private variables;
    private shared;
    private parent?;
    constructor(variables: Record<string, any> | undefined, shared: Record<string, any>, parent?: Scope);
    get(key: string): any;
    getLocal(key: string): any;
    getShared(key: string): any;
    setShared(key: string, value: any): void;
    setLocal(key: string, value: any): void;
    createChild(variables?: Record<string, any>): Scope;
}

declare const transformTree: (tree: Root, props?: Record<string, any>, shared?: Record<string, any>) => Promise<Root>;

declare const NODE_TYPES: {
    readonly MDX_JSX_FLOW_ELEMENT: "mdxJsxFlowElement";
    readonly MDX_JSX_TEXT_ELEMENT: "mdxJsxTextElement";
    readonly MDX_JSX_ESM: "mdxjsEsm";
    readonly YAML: "yaml";
    readonly MDX_TEXT_EXPRESSION: "mdxTextExpression";
    readonly MDX_FLOW_EXPRESSION: "mdxFlowExpression";
    readonly LIST: "list";
    readonly LIST_ITEM: "listItem";
    readonly TEXT: "text";
    readonly PARAGRAPH: "paragraph";
    readonly HTML: "html";
};

interface NodeHelpers {
    isMdxJsxElement(node: Node): boolean;
    isMdxJsxFlowElement(node: Node): boolean;
    isMdxJsxTextElement(node: Node): boolean;
    isParentNode(node: Node): boolean;
    toMarkdown(node: Node): string;
    hasFunctionBody(node: Node): boolean;
    getFunctionBody(node: Node): {
        body: Node[];
        argumentNames: string[];
    };
    NODE_TYPES: typeof NODE_TYPES;
}
interface PluginContext {
    nodeHelpers: NodeHelpers;
    createNodeTransformer: (scope: Scope) => any;
    scope: Scope;
    tagName: string;
}
declare abstract class TagPlugin<Props = Record<string, any>> {
    abstract transform(props: Props, children: Node[], context: PluginContext): Promise<Node[] | Node>;
}

interface ForEachProps<T = any> {
    children: (item: T, index: number) => any;
    arr: Array<T>;
}

interface IfProps {
    condition: boolean;
    children: any;
}
interface ElseIfProps {
    condition: boolean;
    children: any;
}
interface ElseProps {
    children: any;
}

interface RawProps {
    children: any;
}

interface BaseMDXProvidedComponents {
    ForEach: <T = any>(props: ForEachProps<T>) => any;
    If: React.FC<IfProps>;
    ElseIf: React.FC<ElseIfProps>;
    Else: React.FC<ElseProps>;
    Raw: React.FC<RawProps>;
}
type ContentLoader = (modulePath: string) => Promise<string>;

declare function bundle(mdxContent: string, baseDir: string, contentLoader: ContentLoader): Promise<Root>;

declare function compressAst(node: any): void;
declare const getFrontMatter: (tree: Root) => unknown;
declare const stringify: (tree: Root) => string;

declare class TagPluginRegistry {
    private static plugins;
    static register(plugin: TagPlugin, names: string[]): void;
    static get(name: string): TagPlugin | undefined;
    static getAll(): Map<string, TagPlugin>;
    static remove(name: string): void;
    static removeAll(): void;
}

type FilterFunction<Input = any, Output = any, Args extends any[] = any[]> = (input: Input, ...args: Args) => Output;
declare class FilterRegistry {
    private static filters;
    static register(name: string, filterFunction: FilterFunction): void;
    static get(name: string): FilterFunction | undefined;
    static getAll(): Map<string, FilterFunction>;
    static remove(name: string): void;
    static removeAll(): void;
}

interface Filters {
    capitalize: FilterFunction<string, string>;
    upper: FilterFunction<string, string>;
    lower: FilterFunction<string, string>;
    truncate: FilterFunction<string, string, [number]>;
    abs: FilterFunction<number, number>;
    join: FilterFunction<any[], string, [string?]>;
    round: FilterFunction<number, number, [number?]>;
    replace: FilterFunction<string, string, [string, string]>;
    urlencode: FilterFunction<string, string>;
    dump: FilterFunction<any, string>;
}

declare global {
  const capitalize: Filters['capitalize'];
  const upper: Filters['upper'];
  const lower: Filters['lower'];
  const truncate: Filters['truncate'];
  const abs: Filters['abs'];
  const join: Filters['join'];
  const round: Filters['round'];
  const replace: Filters['replace'];
  const urlencode: Filters['urlencode'];
  const dump: Filters['dump'];
  interface MDXProvidedComponents extends BaseMDXProvidedComponents {}
}

declare function load(path: string): Promise<Root>;

export { type BaseMDXProvidedComponents, type ContentLoader, type FilterFunction, FilterRegistry, type PluginContext, TagPlugin, TagPluginRegistry, compressAst, getFrontMatter, load, bundle as parse, stringify, transformTree as transform };
